<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Power Grid Planning: Why Building Together is Better</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- MathJax Configuration -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
        };
      </script>
    <!-- MathJax -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- p5.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.js"></script>

    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            padding-top: 20px;
            padding-bottom: 40px;
        }
        .container {
            max-width: 900px;
        }
        h1, h2, h3 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }
        code {
            background-color: #f0f0f0;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .interactive-viz {
            border: 1px solid #ccc;
            padding: 15px;
            margin-top: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type=range] {
            width: 100%;
        }
        .caption {
            font-size: 0.9em;
            color: #555;
            margin-top: 5px;
            text-align: center;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 2px 5px;
            border-radius: 3px;
        }
        svg {
            display: block;
            margin: auto;
        }
        .bar {
          fill: steelblue;
        }
        .bar:hover {
          fill: brown;
        }
        .axis-label {
            font-size: 0.8em;
            fill: #555;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            width: auto;
            height: auto;
            padding: 5px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
        }
        /* Style for p5.js sketches */
        #interdependenceViz canvas, #braessParadoxViz canvas {
            display: block;
            margin: 10px auto;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Power Grid Planning: Why Building Together is Better</h1>
        <p class="lead">Exploring the crucial link between building power plants and power lines, inspired by the paper "Necessity of Joint Resource and Transmission Expansion Planning in Presence of System and Policy Uncertainties" by Mehrtash et al.</p>

        <hr>

        <h2>The Challenge: Powering the Future</h2>
        <p>Imagine you're in charge of designing the power grid for the next few decades. It's a huge task! You need to make sure there's enough electricity to meet growing demand (think electric cars, smarter homes). You also need to connect new renewable energy sources, like wind and solar farms, which are often built far from cities. Plus, existing equipment gets old and needs replacing, and there are environmental goals to meet.</p>
        <p>This involves two main types of decisions:</p>
        <ul>
            <li><strong>Generation Expansion Planning (GEP):</strong> Deciding where and what kind of new power plants to build (or which old ones to retire). Should it be a solar farm out west, a wind farm offshore, or a natural gas plant near the city?</li>
            <li><strong>Transmission Expansion Planning (TEP):</strong> Deciding where to build new high-voltage power lines to carry electricity from where it's generated to where it's needed. Do we need a new line connecting the windy plains to the industrial center?</li>
        </ul>
        <p>Traditionally, these decisions have often been made somewhat separately. Power companies decide on building plants (GEP), while grid operators focus on the lines (TEP). But does this separation make sense? The paper argues: probably not.</p>

        <h2>Why Generation and Transmission Depend on Each Other</h2>
        <p>Think about it: building a massive new solar farm (GEP) is useless if there aren't enough power lines (TEP) to carry its electricity to customers. Conversely, building a super-efficient new power line (TEP) might suddenly make it economical to build a cheaper power plant further away (GEP) that wasn't viable before.</p>
        <p>They are two sides of the same coin. Let's explore this interdependence with a simple model:</p>

        <div class="interactive-viz">
            <h3>Simple Grid: Interdependence Demo</h3>
            <p>Imagine a city needing power. It can get it from a nearby, more expensive local plant, or a cheaper remote plant, but the remote plant needs a transmission line. Should we build the line?</p>
            <div id="interdependenceViz"></div>
            <label for="demandSlider">City Demand (Units): <span id="demandValue">50</span></label>
            <input type="range" id="demandSlider" min="10" max="100" value="50">

            <label for="remoteCostSlider">Remote Plant Cost ($/Unit): <span id="remoteCostValue">2</span></label>
            <input type="range" id="remoteCostSlider" min="1" max="10" value="2" step="0.5">

            <label for="localCostSlider">Local Plant Cost ($/Unit): <span id="localCostValue">5</span></label>
            <input type="range" id="localCostSlider" min="1" max="10" value="5" step="0.5">

            <label for="lineCostSlider">Transmission Line Annual Cost ($): <span id="lineCostValue">100</span></label>
            <input type="range" id="lineCostSlider" min="0" max="300" value="100" step="10">

            <p style="margin-top: 15px;"><strong>Total Annual Cost:</strong> $<span id="totalCostValue">?</span></p>
            <p><strong>Decision:</strong> <span id="decisionText">Calculating...</span></p>
            <p class="caption">Adjust the sliders to see when building the transmission line becomes the cheaper option. Notice how demand, plant costs, and line costs all influence the decision.</p>
        </div>

        <p>As you can see, the best choice depends on all the factors together. Planning GEP and TEP in isolation might lead to building the wrong things, costing more money in the long run.</p>

        <h2>Study 1: How We Plan Transmission - Screening vs. Optimization</h2>
        <p>How do grid planners decide <em>which</em> new power lines to build? The paper looks at two approaches:</p>
        <ol>
            <li><strong>Project-by-Project Screening:</strong> This is common in practice. Planners look at a list of potential new lines. They estimate the benefit (e.g., cost savings from reducing congestion) of building <em>each line individually</em>. They might then pick the ones that look best on their own, perhaps based on a <a href="https://en.wikipedia.org/wiki/Cost%E2%80%93benefit_analysis" target="_blank">benefit-cost ratio</a>. [1, 9, 10, 11, 14]</li>
            <li><strong>Optimization-Based TEP:</strong> This is common in academic research. Planners use sophisticated computer models that consider <em>all</em> candidate lines <em>simultaneously</em>. The model tries to find the combination of lines that minimizes the total system cost (including building the lines and operating the grid) while respecting physical limits (like how much power a line can carry). [8, 13, 15, 18, 20]</li>
        </ol>

        <h3>The Catch: Why Individual Benefits Can Be Misleading (Braess's Paradox)</h3>
        <p>The screening approach seems logical, but it has a potential flaw. Sometimes, adding a new connection that looks beneficial <em>in isolation</em> can actually make the overall system perform <em>worse</em>. This is related to a concept called <a href="https://en.wikipedia.org/wiki/Braess%27s_paradox" target="_blank">Braess's Paradox</a>, often illustrated with traffic networks, but applicable to power grids too. [2, 3, 4, 6, 7]</p>

        <div class="interactive-viz">
            <h3>Braess's Paradox Demo</h3>
            <p>Imagine power flowing from Start to End. It can go via A or B. Adding a "shortcut" line between A and B seems like it should help, right? Let's see.</p>
             <div id="braessParadoxViz"></div>
             <button id="toggleShortcutBtn" class="btn btn-primary btn-sm">Add Shortcut A-B</button>
             <p style="margin-top: 10px;"><strong>Total System "Cost" (Congestion):</strong> <span id="braessCostValue">?</span></p>
             <p><strong>Flow Distribution:</strong> <span id="braessFlowValue">?</span></p>
             <p class="caption">Click the button to add/remove the shortcut line (A-B). Observe how adding the seemingly helpful line can increase the total system cost (representing congestion or inefficiency) because flows reroute suboptimally.</p>
        </div>

        <p>The paper simulated both screening and optimization on a large, realistic model of the Texas (ERCOT) power grid. They randomly generated 10,000 potential new lines.</p>
        <ul>
            <li>In the <strong>screening</strong> simulation, they picked the top 27 lines based on their individual estimated benefit.</li>
            <li>In the <strong>optimization</strong> simulation, the computer model chose the best set of 27 lines out of the top 50 candidates from the screening phase (to make it computationally feasible but still find a good solution).</li>
        </ul>
        <p>The results were striking:</p>

        <div class="interactive-viz">
            <h3>Screening vs. Optimization Results (Based on Paper's Table I)</h3>
            <p>Comparing the annual system performance:</p>
            <div id="screeningVsOptViz"></div>
            <p class="caption">Hover over the bars to see the values. "Load Shedding" means demand that couldn't be met (blackouts). Lower is better for both cost and load shedding. Optimization provides significantly larger benefits.</p>
        </div>

        <p>The optimization approach resulted in <span class="highlight">more than double the annual cost savings</span> compared to the screening approach, and it <span class="highlight">reduced unmet demand (load shedding) by almost 80%</span> more. This strongly suggests that looking at the system holistically via optimization is far superior to picking lines one by one.</p>

        <h2>Study 2: Planning Everything Together - GEP vs. GTEP under Uncertainty</h2>
        <p>Okay, optimization seems better for transmission (TEP). But what about the bigger picture – planning both generation (GEP) and transmission (TEP) together? This is often called <strong>co-optimization</strong> or <strong>joint GTEP</strong>.</p>
        <p>The real world is uncertain. We don't know exactly how much electricity demand will grow, what environmental policies will be enacted (like carbon taxes), or how quickly old power plants will retire. Good planning needs to account for these possibilities.</p>
        <p>The paper compared two planning strategies across four possible future scenarios for the year 2030:</p>
        <ul>
            <li><strong>GEP Only:</strong> Assume the transmission grid is fixed (no new lines built) and only optimize the generation investments (new plants).</li>
            <li><strong>Joint GTEP:</strong> Optimize <em>both</em> new transmission lines <em>and</em> new generation investments simultaneously.</li>
        </ul>
        <p>The Four Scenarios:</p>
        <ol>
            <li><strong>S1: Reference:</strong> Moderate demand growth, some planned retirements.</li>
            <li><strong>S2: Environmental Regs:</strong> Same as S1, but with a carbon tax ($50/ton) making fossil fuels more expensive.</li>
            <li><strong>S3: Aggressive Retirements:</strong> Same as S1, but many more coal and gas plants retire early.</li>
            <li><strong>S4: High Load Growth:</strong> Much higher electricity demand growth (e.g., faster EV adoption).</li>
        </ol>

        <p>For each scenario, they ran both the GEP-only and the joint GTEP models to find the best investment plan. How did they compare?</p>

        <div class="interactive-viz">
            <h3>GEP vs. GTEP Performance Across Scenarios (Based on Paper's Figs 4 & 6)</h3>
            <p>Select a scenario to see the comparison:</p>
            <div class="btn-group" role="group" aria-label="Scenario Selection" id="scenarioSelector">
              <button type="button" class="btn btn-secondary active" data-scenario="S1">S1: Reference</button>
              <button type="button" class="btn btn-secondary" data-scenario="S2">S2: Carbon Tax</button>
              <button type="button" class="btn btn-secondary" data-scenario="S3">S3: Retirements</button>
              <button type="button" class="btn btn-secondary" data-scenario="S4">S4: High Demand</button>
            </div>
            <div id="gepVsGtepViz" style="margin-top: 15px;"></div>
            <p class="caption">This chart shows the total annual cost (building new things + running the grid) and the amount of load shedding (unmet demand) during peak hours. Lower is better for both. Observe how GTEP consistently performs better.</p>
        </div>

        <p>The results are clear: In <span class="highlight">every single scenario</span>, planning generation and transmission together (GTEP) resulted in:</p>
        <ul>
            <li><strong>Lower Overall Costs:</strong> The sum of investment costs and operational costs was significantly less.</li>
            <li><strong>Higher Reliability:</strong> Much less load shedding occurred, meaning fewer blackouts during peak times.</li>
        </ul>
        <p>Interestingly, the study also found that while the <em>specific</em> power plants chosen depended heavily on the scenario (e.g., more renewables under a carbon tax), the decisions about <em>which transmission lines and energy storage</em> to build were more consistent across the different futures. This suggests that transmission investments can be more robust hedges against uncertainty.</p>

        <h2>The Underlying Math: Optimization</h2>
        <p>How do these computer models find the "best" plan? They use a mathematical technique called <a href="https://en.wikipedia.org/wiki/Mathematical_optimization" target="_blank">optimization</a>. [8, 13, 15, 18, 20] The core idea is to define:</p>
        <ol>
            <li><strong>An Objective Function:</strong> This is what we want to minimize (or maximize). In grid planning, it's usually the total cost, which includes:
                <ul>
                    <li>The cost of building new lines, power plants, and storage (Investment Cost).</li>
                    <li>The cost of running the grid day-to-day (fuel for power plants, managing congestion) (Operation Cost).</li>
                    <li>Sometimes, a penalty cost for load shedding (representing the economic cost of blackouts).</li>
                </ul>
                Mathematically, we write this as: `min f(x)` where `f` is the total cost function and `x` represents all the decisions (which lines/plants to build, how much power each plant generates).
            </li>
            <li><strong>Constraints:</strong> These are the rules and physical limits the plan must obey. Examples include:
                <ul>
                    <li>Power Balance: Electricity generated must equal electricity consumed (plus losses) everywhere.</li>
                    <li>Line Limits: Power flow on each line cannot exceed its thermal capacity.</li>
                    <li>Generator Limits: Each power plant has a maximum output.</li>
                    <li>Resource Availability: Solar panels only work when it's sunny, wind turbines only when it's windy.</li>
                    <li>Policy Rules: Requirements for renewable energy, emission limits.</li>
                </ul>
                Mathematically, these are represented as equations (`g(x) = 0`) and inequalities (`h(x) ≤ 0`).
            </li>
        </ol>
        <p>The overall problem looks like this:</p>
        $$ \min_{x} f(x) $$
        $$ \text{subject to} \quad g(x) = 0 $$
        $$ \quad h(x) \le 0 $$
        <p>Finding the set of decisions `x` that satisfies all the constraints and gives the lowest possible value for `f(x)` is a complex puzzle, especially for large grids with many options and uncertainties. Powerful algorithms and computers are needed to solve these <a href="https://en.wikipedia.org/wiki/Mixed-integer_programming" target="_blank">mixed-integer programming</a> problems, but as the paper shows, the effort is worthwhile. [5, 12, 16, 17, 19]</p>
        <p>The interactive visualizations you played with earlier are simplified representations of this idea. Adjusting sliders changed parameters within the cost function (`f(x)`) or the constraints (`h(x)`), leading the simple "solver" (the Javascript code) to find a new optimal decision.</p>

        <h2>Conclusion: Plan Together for a Better Grid</h2>
        <p>The core message from the paper by Mehrtash et al. is compelling: separating the planning of power generation (GEP) and transmission (TEP) is inefficient and can lead to higher costs and lower reliability.</p>
        <ul>
            <li>Simple "screening" methods for choosing transmission lines can be misleading and perform much worse than holistic optimization.</li>
            <li>Jointly planning generation and transmission (GTEP) consistently yields better outcomes – lower total costs and less unmet demand – compared to planning generation alone, especially when facing an uncertain future.</li>
        </ul>
        <p>As we transition towards a grid with more renewable energy, electric vehicles, and changing demand patterns, the interdependence between where we generate power and how we transport it becomes even more critical. Adopting integrated planning approaches, like the GTEP methods explored in this paper, will be essential for building the affordable, reliable, and sustainable power grid of the future.</p>

    </div>

    <!-- Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // --- Visualization 1: Interdependence Demo ---
        const interdependenceSketch = (p) => {
            let canvasWidth = 400;
            let canvasHeight = 200;
            let cityNode, localNode, remoteNode;
            let demandSlider, remoteCostSlider, localCostSlider, lineCostSlider;
            let totalCostValue, decisionText;
            let showLine = false;

            p.setup = () => {
                p.createCanvas(canvasWidth, canvasHeight).parent('interdependenceViz');
                cityNode = p.createVector(canvasWidth / 2, canvasHeight * 0.8);
                localNode = p.createVector(canvasWidth / 2, canvasHeight * 0.2);
                remoteNode = p.createVector(canvasWidth * 0.1, canvasHeight * 0.2);

                // Get handles to HTML elements
                demandSlider = p.select('#demandSlider');
                remoteCostSlider = p.select('#remoteCostSlider');
                localCostSlider = p.select('#localCostSlider');
                lineCostSlider = p.select('#lineCostSlider');
                totalCostValue = p.select('#totalCostValue');
                decisionText = p.select('#decisionText');

                // Add input listeners
                demandSlider.input(updateCalculation);
                remoteCostSlider.input(updateCalculation);
localCostSlider.input(updateCalculation);
                lineCostSlider.input(updateCalculation);

                updateCalculation(); // Initial calculation
            };

            function updateCalculation() {
                // Update displayed slider values
                p.select('#demandValue').html(demandSlider.value());
                p.select('#remoteCostValue').html(remoteCostSlider.value());
                p.select('#localCostValue').html(localCostSlider.value());
                p.select('#lineCostValue').html(lineCostSlider.value());

                let demand = parseFloat(demandSlider.value());
                let remoteCost = parseFloat(remoteCostSlider.value());
                let localCost = parseFloat(localCostSlider.value());
                let lineCost = parseFloat(lineCostSlider.value());

                // Calculate cost without transmission line (must use local plant)
                let costWithoutLine = demand * localCost;

                // Calculate cost with transmission line (use cheaper of local or remote)
                let generationCostWithLine = Math.min(localCost, remoteCost) * demand;
                let costWithLine = generationCostWithLine + lineCost;

                let finalCost;
                if (costWithLine < costWithoutLine) {
                    showLine = true;
                    finalCost = costWithLine;
                    decisionText.html("Build the transmission line (use cheaper plant).");
                     decisionText.style('color', 'green');
                } else {
                    showLine = false;
                    finalCost = costWithoutLine;
                    decisionText.html("Do not build the line (use local plant).");
                     decisionText.style('color', 'red');
                }
                totalCostValue.html(finalCost.toFixed(2));
            }

            p.draw = () => {
                p.background(240);
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(12);

                // Draw Nodes
                p.fill(0, 102, 153); // Blue for city
                p.ellipse(cityNode.x, cityNode.y, 40, 40);
                p.fill(255);
                p.text("City", cityNode.x, cityNode.y);

                p.fill(204, 102, 0); // Orange for local plant
                p.ellipse(localNode.x, localNode.y, 40, 40);
                 p.fill(255);
                p.text("Local\nPlant", localNode.x, localNode.y);

                p.fill(0, 153, 51); // Green for remote plant
                p.ellipse(remoteNode.x, remoteNode.y, 40, 40);
                 p.fill(255);
                p.text("Remote\nPlant", remoteNode.x, remoteNode.y);

                // Draw Lines
                p.strokeWeight(2);
                p.stroke(150); // Gray for existing connection
                p.line(localNode.x, localNode.y, cityNode.x, cityNode.y);

                if (showLine) {
                    p.stroke(50, 200, 50); // Green for built line
                    p.strokeWeight(4);
                    p.line(remoteNode.x, remoteNode.y, cityNode.x, cityNode.y);
                } else {
                     p.stroke(200, 50, 50); // Red dashed for potential line
                     p.strokeWeight(2);
                     drawDashedLine(remoteNode.x, remoteNode.y, cityNode.x, cityNode.y, 5);
                }
            };

            function drawDashedLine(x1, y1, x2, y2, dashLength) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const numDashes = distance / dashLength;
                const dashX = dx / numDashes;
                const dashY = dy / numDashes;

                p.push();
                p.strokeWeight(1);
                let currentX = x1;
                let currentY = y1;
                for (let i = 0; i < numDashes; i += 2) {
                    p.line(currentX, currentY, currentX + dashX, currentY + dashY);
                    currentX += dashX * 2;
                    currentY += dashY * 2;
                }
                p.pop();
            }
        };
        new p5(interdependenceSketch);


        // --- Visualization 2: Braess Paradox Demo ---
        const braessParadoxSketch = (p) => {
            let canvasWidth = 400;
            let canvasHeight = 200;
            let startNode, endNode, nodeA, nodeB;
            let showShortcut = false;
            let costValue, flowValue;

            // Define link cost functions (cost depends on flow x)
            // Start->A: 10*x
            // B->End: 10*x
            // Start->B: 50 + x
            // A->End: 50 + x
            // A->B (Shortcut): 10 + x
            const costSA = (x) => 10 * x;
            const costBE = (x) => 10 * x;
            const costSB = (x) => 50 + x;
            const costAE = (x) => 50 + x;
            const costAB = (x) => 10 + x; // Shortcut cost

            p.setup = () => {
                p.createCanvas(canvasWidth, canvasHeight).parent('braessParadoxViz');
                startNode = p.createVector(canvasWidth * 0.1, canvasHeight / 2);
                endNode = p.createVector(canvasWidth * 0.9, canvasHeight / 2);
                nodeA = p.createVector(canvasWidth * 0.4, canvasHeight * 0.2);
                nodeB = p.createVector(canvasWidth * 0.4, canvasHeight * 0.8);

                costValue = p.select('#braessCostValue');
                flowValue = p.select('#braessFlowValue');
                let toggleBtn = p.select('#toggleShortcutBtn');
                toggleBtn.mousePressed(toggleShortcut);

                calculateFlows(); // Initial calculation
            };

             function toggleShortcut() {
                showShortcut = !showShortcut;
                p.select('#toggleShortcutBtn').html(showShortcut ? 'Remove Shortcut A-B' : 'Add Shortcut A-B');
                calculateFlows();
            }

            // Simplified flow calculation (assuming total flow = 6 units seeking minimum cost path)
            // This is a highly simplified equilibrium calculation for demonstration
            function calculateFlows() {
                let totalFlow = 6;
                let flowSABE, flowSBE, flowSAE; // Flows on paths
                let totalCost;
                let flowDesc;

                if (!showShortcut) {
                    // Equilibrium: flow splits to equalize path costs (SAE vs SBE)
                    // Cost(SAE) = 10*x + (50 + x)
                    // Cost(SBE) = (50 + (6-x)) + 10*(6-x)
                    // Solve 11x + 50 = 50 + 6 - x + 60 - 10x => 11x + 50 = 116 - 11x => 22x = 66 => x = 3
                    flowSAE = 3;
                    flowSBE = 3;
                    let costSAE = costSA(flowSAE) + costAE(flowSAE);
                    let costSBE = costSB(flowSBE) + costBE(flowSBE);
                    totalCost = flowSAE * costSAE + flowSBE * costSBE; // Weighted cost
                    flowDesc = `Path Start-A-End: ${flowSAE.toFixed(1)} units (Cost ${costSAE.toFixed(0)}), Path Start-B-End: ${flowSBE.toFixed(1)} units (Cost ${costSBE.toFixed(0)})`;
                } else {
                    // With shortcut, the path S-A-B-E becomes attractive
                    // Assume everyone takes S-A-B-E initially (worst case reasoning for paradox)
                    // Cost(SABE) = Cost(SA)(6) + Cost(AB)(6) + Cost(BE)(6) = 10*6 + (10+6) + 10*6 = 60 + 16 + 60 = 136
                    // Cost(SAE) at flow=0 = 50. Cost(SBE) at flow=0 = 50.
                    // A more complex equilibrium would form, but let's show the paradox potential:
                    // If all 6 units try path S-A-B-E:
                    let cost_SABE_all = costSA(totalFlow) + costAB(totalFlow) + costBE(totalFlow); // 10*6 + (10+6) + 10*6 = 60+16+60 = 136
                    // If flow splits 3/3 like before:
                    // Cost(SAE) = 10*3 + (50+3) = 30+53 = 83
                    // Cost(SBE) = (50+3) + 10*3 = 53+30 = 83
                    // Now consider path SABE cost if flow is 3/3: Cost(SA)(3)+Cost(AB)(?) + Cost(BE)(3)
                    // The paradox arises because the individual incentive is to switch to SABE if its cost is lower.
                    // Let's assume the equilibrium shifts: all flow goes S-A-B-E
                    flowSABE = totalFlow;
                    totalCost = flowSABE * cost_SABE_all; // Cost if all use the 'shortcut' path
                     flowDesc = `All ${totalFlow} units take Path Start-A-B-End (Cost ${cost_SABE_all.toFixed(0)}) due to individual incentive, making overall cost higher.`;
                     // A more realistic equilibrium is complex, but this illustrates the potential negative impact.
                }

                costValue.html(totalCost.toFixed(0));
                flowValue.html(flowDesc);
            }


            p.draw = () => {
                p.background(240);
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(12);

                // Draw Nodes
                p.fill(0, 102, 153);
                p.ellipse(startNode.x, startNode.y, 30, 30); p.text("Start", startNode.x, startNode.y);
                p.ellipse(endNode.x, endNode.y, 30, 30); p.text("End", endNode.x, endNode.y);
                p.fill(204, 102, 0);
                p.ellipse(nodeA.x, nodeA.y, 30, 30); p.text("A", nodeA.x, nodeA.y);
                p.ellipse(nodeB.x, nodeB.y, 30, 30); p.text("B", nodeB.x, nodeB.y);

                // Draw Lines
                p.strokeWeight(2);
                p.stroke(150);
                // Base lines
                p.line(startNode.x, startNode.y, nodeA.x, nodeA.y); // SA
                p.line(startNode.x, startNode.y, nodeB.x, nodeB.y); // SB
                p.line(nodeA.x, nodeA.y, endNode.x, endNode.y); // AE
                p.line(nodeB.x, nodeB.y, endNode.x, endNode.y); // BE

                // Shortcut line
                if (showShortcut) {
                    p.stroke(50, 200, 50); // Green
                    p.strokeWeight(4);
                    p.line(nodeA.x, nodeA.y, nodeB.x, nodeB.y); // AB
                }
            };
        };
        new p5(braessParadoxSketch);


        // --- Visualization 3: Screening vs. Optimization Results ---
        const screeningData = [
            { approach: "Original System", cost: 7.57, shedding: 3093 },
            { approach: "Screening (Top 27 Indiv.)", cost: 6.99, shedding: 1558 },
            { approach: "Optimization (Best 27 Combo)", cost: 6.19, shedding: 366 }
        ];

        const margin = {top: 20, right: 30, bottom: 60, left: 60},
              width = 450 - margin.left - margin.right,
              height = 300 - margin.top - margin.bottom;

        const svgScreening = d3.select("#screeningVsOptViz")
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Tooltip Div
        const tooltipScreening = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        // X axis
        const xScreening = d3.scaleBand()
          .range([ 0, width ])
          .domain(screeningData.map(d => d.approach))
          .padding(0.2);
        svgScreening.append("g")
          .attr("transform", `translate(0,${height})`)
          .call(d3.axisBottom(xScreening))
          .selectAll("text")
            .attr("transform", "translate(-10,0)rotate(-20)")
            .style("text-anchor", "end");

        // Y axis - Cost
        const yCost = d3.scaleLinear()
          .domain([0, d3.max(screeningData, d => d.cost) * 1.1])
          .range([ height, 0]);
        svgScreening.append("g")
          .call(d3.axisLeft(yCost));
        svgScreening.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left + 15)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("class", "axis-label")
            .text("Annual Op. Cost (Billion $)");

        // Y axis - Load Shedding (Right Side)
        const yShedding = d3.scaleLinear()
            .domain([0, d3.max(screeningData, d => d.shedding) * 1.1])
            .range([height, 0]);
        svgScreening.append("g")
            .attr("transform", `translate(${width}, 0)`)
            .call(d3.axisRight(yShedding));
         svgScreening.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", width + margin.right - 15)
            .attr("x",0 - (height / 2))
            .attr("dy", "-0.5em")
            .style("text-anchor", "middle")
            .attr("class", "axis-label")
            .text("Peak Load Shedding (MW)");


        // Bars - Cost
        svgScreening.selectAll(".barCost")
          .data(screeningData)
          .join("rect")
            .attr("class", "bar barCost")
            .attr("x", d => xScreening(d.approach))
            .attr("y", d => yCost(d.cost))
            .attr("width", xScreening.bandwidth() / 2) // Half width for cost
            .attr("height", d => height - yCost(d.cost))
            .attr("fill", "#69b3a2")
             .on("mouseover", function(event, d) {
                tooltipScreening.transition().duration(200).style("opacity", .9);
                tooltipScreening.html(`Approach: ${d.approach}<br/>Cost: $${d.cost.toFixed(2)} Billion`)
                    .style("left", (event.pageX + 5) + "px")
                    .style("top", (event.pageY - 28) + "px");
                d3.select(this).style("fill", "darkgreen");
            })
            .on("mouseout", function(d) {
                tooltipScreening.transition().duration(500).style("opacity", 0);
                 d3.select(this).style("fill", "#69b3a2");
            });


        // Bars - Load Shedding
        svgScreening.selectAll(".barShedding")
          .data(screeningData)
          .join("rect")
            .attr("class", "bar barShedding")
            .attr("x", d => xScreening(d.approach) + xScreening.bandwidth() / 2) // Start at half width
            .attr("y", d => yShedding(d.shedding))
            .attr("width", xScreening.bandwidth() / 2) // Half width for shedding
            .attr("height", d => height - yShedding(d.shedding))
            .attr("fill", "#ff7f0e") // Orange color
             .on("mouseover", function(event, d) {
                tooltipScreening.transition().duration(200).style("opacity", .9);
                tooltipScreening.html(`Approach: ${d.approach}<br/>Shedding: ${d.shedding} MW`)
                    .style("left", (event.pageX + 5) + "px")
                    .style("top", (event.pageY - 28) + "px");
                 d3.select(this).style("fill", "darkred");
            })
            .on("mouseout", function(d) {
                tooltipScreening.transition().duration(500).style("opacity", 0);
                 d3.select(this).style("fill", "#ff7f0e");
            });

         // Legend
         svgScreening.append("rect").attr("x",width-100).attr("y",0).attr("width", 10).attr("height", 10).style("fill", "#69b3a2")
         svgScreening.append("rect").attr("x",width-100).attr("y",20).attr("width", 10).attr("height", 10).style("fill", "#ff7f0e")
         svgScreening.append("text").attr("x", width-85).attr("y", 5).text("Cost").style("font-size", "12px").attr("alignment-baseline","middle")
         svgScreening.append("text").attr("x", width-85).attr("y", 25).text("Shedding").style("font-size", "12px").attr("alignment-baseline","middle")


        // --- Visualization 4: GEP vs GTEP Performance ---
        const scenarioData = {
            // Values estimated/interpreted from Figs 4 & 6 in the paper
            // Overall Cost = Operation Cost (Fig 4) + Investment Cost (Fig 5 sum)
            // Load Shedding from Fig 4 (Peak hour GW converted to MW)
            S1: [ // Reference
                { method: "GEP", cost: 4.0 + 0.9, shedding: 1.0 * 1000 }, // OpCost + InvCost(Gen+Sto)
                { method: "GTEP", cost: 3.2 + 0.2 + 0.6, shedding: 0.2 * 1000 } // OpCost + InvCost(Line+Gen+Sto)
            ],
            S2: [ // Carbon Tax
                { method: "GEP", cost: 3.5 + 1.0, shedding: 1.0 * 1000 },
                { method: "GTEP", cost: 2.8 + 0.2 + 0.7, shedding: 0.2 * 1000 }
            ],
            S3: [ // Retirements
                { method: "GEP", cost: 4.8 + 0.9, shedding: 1.5 * 1000 },
                { method: "GTEP", cost: 3.8 + 0.2 + 0.6, shedding: 0.3 * 1000 }
            ],
            S4: [ // High Demand
                { method: "GEP", cost: 5.5 + 1.0, shedding: 2.0 * 1000 },
                { method: "GTEP", cost: 4.5 + 0.2 + 0.7, shedding: 0.5 * 1000 }
            ]
        };

        const svgGepGtep = d3.select("#gepVsGtepViz")
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Tooltip Div
        const tooltipGepGtep = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        // X axis - Methods (GEP, GTEP)
        const xGepGtep = d3.scaleBand()
          .range([ 0, width ])
          .domain(["GEP", "GTEP"])
          .padding(0.4); // Increased padding
        const xAxisGepGtep = svgGepGtep.append("g")
          .attr("transform", `translate(0,${height})`)
          .call(d3.axisBottom(xGepGtep));

        // Y axis - Cost (Left)
        const yCostGepGtep = d3.scaleLinear().range([ height, 0]);
        const yAxisCostGepGtep = svgGepGtep.append("g");
         svgGepGtep.append("text") // Label for Cost Axis
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left + 15)
            .attr("x",0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .attr("class", "axis-label")
            .style("fill", "#1f77b4") // Blue
            .text("Total Annual Cost (Billion $)");


        // Y axis - Load Shedding (Right)
        const yShedGepGtep = d3.scaleLinear().range([ height, 0]);
        const yAxisShedGepGtep = svgGepGtep.append("g")
            .attr("transform", `translate(${width}, 0)`);
         svgGepGtep.append("text") // Label for Shedding Axis
            .attr("transform", "rotate(-90)")
            .attr("y", width + margin.right - 15)
            .attr("x",0 - (height / 2))
            .attr("dy", "-0.5em")
            .style("text-anchor", "middle")
            .attr("class", "axis-label")
             .style("fill", "#ff7f0e") // Orange
            .text("Peak Load Shedding (MW)");

        function updateGepGtepChart(scenario) {
            const data = scenarioData[scenario];

            // Update Y axis domains
            yCostGepGtep.domain([0, d3.max(data, d => d.cost) * 1.1]);
            yAxisCostGepGtep.transition().duration(500).call(d3.axisLeft(yCostGepGtep));

            yShedGepGtep.domain([0, d3.max(data, d => d.shedding) * 1.1]);
            yAxisShedGepGtep.transition().duration(500).call(d3.axisRight(yShedGepGtep));

            // Bars - Cost
            const barsCost = svgGepGtep.selectAll(".barCostGepGtep")
              .data(data, d => d.method); // Key function for object constancy

            barsCost.enter()
              .append("rect")
                .attr("class", "bar barCostGepGtep")
                .attr("x", d => xGepGtep(d.method))
                .attr("width", xGepGtep.bandwidth() / 2)
                .attr("fill", "#1f77b4") // Blue color for cost
                .attr("y", d => yCostGepGtep(0)) // Start from bottom
                .attr("height", 0)
                .on("mouseover", function(event, d) {
                    tooltipGepGtep.transition().duration(200).style("opacity", .9);
                    tooltipGepGtep.html(`Method: ${d.method}<br/>Cost: $${d.cost.toFixed(2)} Billion`)
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY - 28) + "px");
                    d3.select(this).style("fill", "darkblue");
                })
                .on("mouseout", function(d) {
                    tooltipGepGtep.transition().duration(500).style("opacity", 0);
                     d3.select(this).style("fill", "#1f77b4");
                })
              .merge(barsCost) // Update existing bars
                .transition().duration(500)
                .attr("x", d => xGepGtep(d.method))
                .attr("y", d => yCostGepGtep(d.cost))
                .attr("height", d => height - yCostGepGtep(d.cost));

            barsCost.exit().remove(); // Remove old bars if necessary (not needed here)


             // Bars - Load Shedding
            const barsShed = svgGepGtep.selectAll(".barShedGepGtep")
              .data(data, d => d.method);

             barsShed.enter()
              .append("rect")
                .attr("class", "bar barShedGepGtep")
                .attr("x", d => xGepGtep(d.method) + xGepGtep.bandwidth() / 2)
                .attr("width", xGepGtep.bandwidth() / 2)
                .attr("fill", "#ff7f0e") // Orange color for shedding
                .attr("y", d => yShedGepGtep(0)) // Start from bottom
                .attr("height", 0)
                 .on("mouseover", function(event, d) {
                    tooltipGepGtep.transition().duration(200).style("opacity", .9);
                    tooltipGepGtep.html(`Method: ${d.method}<br/>Shedding: ${d.shedding.toFixed(0)} MW`)
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY - 28) + "px");
                    d3.select(this).style("fill", "darkred");
                })
                .on("mouseout", function(d) {
                    tooltipGepGtep.transition().duration(500).style("opacity", 0);
                     d3.select(this).style("fill", "#ff7f0e");
                })
               .merge(barsShed) // Update existing bars
                 .transition().duration(500)
                 .attr("x", d => xGepGtep(d.method) + xGepGtep.bandwidth() / 2)
                 .attr("y", d => yShedGepGtep(d.shedding))
                 .attr("height", d => height - yShedGepGtep(d.shedding));

            barsShed.exit().remove();
        }

        // Initial chart draw
        updateGepGtepChart('S1');

        // Scenario selector buttons
        d3.selectAll('#scenarioSelector button').on('click', function() {
            // Update active button style
            d3.selectAll('#scenarioSelector button').classed('active', false);
            d3.select(this).classed('active', true);
            // Update chart
            const selectedScenario = d3.select(this).attr('data-scenario');
            updateGepGtepChart(selectedScenario);
        });


    </script>

</body>
</html>