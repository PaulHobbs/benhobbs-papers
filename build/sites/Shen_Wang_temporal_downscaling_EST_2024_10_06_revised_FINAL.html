<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Understanding Power Grid Emissions: Downscaling for the Future</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- MathJax Configuration -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
        };
      </script>
    <!-- MathJax -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            padding-top: 20px;
        }
        .container {
            max-width: 900px;
        }
        h1, h2, h3 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }
        .interactive-visualization {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .axis path,
        .axis line {
            fill: none;
            stroke: #333;
            shape-rendering: crispEdges;
        }
        .axis text {
            font-size: 11px;
            fill: #333;
        }
        .line {
            fill: none;
            stroke-width: 2px;
        }
        .area {
            opacity: 0.7;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 6px;
            font-size: 12px;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
        }
        .slider-label {
            font-size: 0.9em;
            margin-bottom: 0;
        }
        .slider-value {
            font-weight: bold;
        }
        code {
            background-color: #eee;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .highlight {
             background-color: #fff3cd;
             padding: 2px 4px;
             border-radius: 3px;
        }
        .explanation {
            font-size: 0.95em;
            color: #555;
        }
    </style>
</head>
<body>
    <div class="container">

        <h1>Bridging the Gap: Why Hourly Power Emissions Matter</h1>

        <p>Imagine you're trying to understand the air quality in your city tomorrow, next year, or even decades from now. Air quality depends heavily on emissions from various sources, including power plants. Now, imagine you're also trying to plan the future of the energy system – deciding where to build new wind farms, solar panels, or power lines, and when to retire old coal plants. These two tasks are deeply connected, but the tools used for each often operate on vastly different timescales.</p>

        <p>Long-term energy models, like the <a href="https://www.eia.gov/outlooks/aeo/nems/documentation/" target="_blank">National Energy Modeling System (NEMS)</a> mentioned in the paper, often look at the big picture. They might simulate energy supply and demand for an entire year using just a handful of representative time periods (like "average summer weekday," "peak winter night," etc.). This simplification makes complex, decades-long simulations computationally feasible.</p>

        <p>However, air quality models, like <a href="https://en.wikipedia.org/wiki/Community_Multiscale_Air_Quality_Modeling_System" target="_blank">CMAQ</a>, need to know what's happening *hour by hour*. The chemical reactions that form pollutants like ozone depend strongly on sunlight and weather conditions that change throughout the day. A power plant releasing pollutants at noon on a sunny, stagnant day has a very different impact than releasing the same amount at midnight during a windy storm.</p>

        <p>This creates a <strong>scale gap</strong>: how do we translate the coarse, yearly forecasts from energy models into the detailed, hourly emissions data needed for air quality simulations, especially when looking decades into the future where the energy system might be radically different?</p>

        <h2>The Traditional Approach: Looking Backwards (SMOKE)</h2>

        <p>A common method, used by tools like the <a href="https://www.cmascenter.org/smoke/" target="_blank">SMOKE</a> (Sparse Matrix Operator Kernel Emissions) model, relies on historical patterns. It takes the *total* annual emissions predicted by a model like NEMS for a certain type of power plant (say, coal plants in a specific region) and distributes them across the hours of the year using a pre-defined *temporal profile* based on how similar plants operated *in the past*.</p>

        <p>Think of it like having a fixed daily schedule. Maybe historical coal plants typically ramped up in the morning, peaked in the afternoon, and ramped down at night. SMOKE applies this same relative shape, just scaling it up or down based on the total projected annual emissions.</p>

        <div class="interactive-visualization card">
            <div class="card-body">
                <h5 class="card-title">Simplified "SMOKE-like" Historical Profile</h5>
                <p class="explanation">This shows a fixed daily emission pattern based on historical operation. You can change the total annual emissions (represented here by scaling the peak), but the *shape* of the daily pattern remains the same. This doesn't account for how weather or a changing grid mix might alter operations hour-by-hour in the future.</p>
                <label for="smokeScaleSlider" class="form-label slider-label">Total Annual Emissions Factor: <span id="smokeScaleValue" class="slider-value">1.0</span>x</label>
                <input type="range" class="form-range" id="smokeScaleSlider" min="0.5" max="2.5" step="0.1" value="1.0">
                <div id="smoke-viz"></div>
            </div>
        </div>

        <p>This historical approach has limitations, especially for future scenarios:</p>
        <ul>
            <li><strong>Doesn't adapt to weather:</strong> A heatwave might drastically increase electricity demand for air conditioning, forcing power plants to operate differently than on an average day. Historical profiles don't capture this specific weather-driven variability.</li>
            <li><strong>Ignores renewable energy intermittency:</strong> Future grids will likely have much more wind and solar power. Solar power peaks midday, reducing the need for traditional plants then, while wind power can vary significantly hour to hour. Historical profiles based on fossil-fuel-dominated grids don't reflect these new operating patterns.</li>
            <li><strong>Assumes the past predicts the future:</strong> The way we operate the grid is changing fundamentally. Relying solely on past patterns might give a misleading picture of future hourly emissions.</li>
        </ul>

        <h2>The Challenge: Renewables and the "Duck Curve"</h2>

        <p>The rise of solar power dramatically changes when traditional power plants (like natural gas or coal) are needed. Electricity demand often peaks in the late afternoon/early evening. However, solar power generation peaks around noon and drops off quickly as the sun sets. </p>

        <p>When you subtract the solar generation from the total electricity demand (<a href="https://en.wikipedia.org/wiki/Gross_load" target="_blank">gross load</a>), the remaining demand that must be met by other power plants (<a href="https://en.wikipedia.org/wiki/Net_load" target="_blank">net load</a>) often forms a shape resembling a duck – high in the morning, dipping sharply midday when solar is abundant, and then ramping up extremely quickly in the evening as solar fades but demand remains high. This is famously known as the <a href="https://en.wikipedia.org/wiki/Duck_curve" target="_blank">Duck Curve</a>.</p>

        <div class="interactive-visualization card">
            <div class="card-body">
                <h5 class="card-title">The Duck Curve Emerges</h5>
                <p class="explanation">Adjust the amount of solar power capacity on the grid. Observe how the "Net Load" (the demand that non-solar plants must meet) changes shape, especially the steep ramp-up needed in the evening. This changing net load dictates when fossil fuel plants run and emit pollutants.</p>
                <label for="solarCapacitySlider" class="form-label slider-label">Solar Capacity (% of Peak Load): <span id="solarCapacityValue" class="slider-value">0</span>%</label>
                <input type="range" class="form-range" id="solarCapacitySlider" min="0" max="70" step="5" value="0">
                <div id="duck-curve-viz"></div>
            </div>
        </div>

        <p>This rapid evening ramp-up requires flexible power plants (often natural gas) to quickly increase generation, leading to significant emissions during those specific hours – a pattern not captured by simple historical profiles.</p>

        <h2>A New Approach: Simulating Future Grid Operations (TDM)</h2>

        <p>The paper proposes a <strong>Temporal Downscaling Method (TDM)</strong> to address these shortcomings. Instead of relying on fixed historical patterns, TDM uses a <span class="highlight">fundamentals-based optimization model</span> to simulate how the power grid would likely operate on an *hourly* basis in a future scenario.</p>

        <p>Here's the core idea:</p>
        <ol>
            <li><strong>Inputs:</strong>
                <ul>
                    <li>Projected power plant fleet for a future year (capacities, fuel types, locations - potentially from a model like <a href="https://www.osti.gov/biblio/1813852" target="_blank">SAG</a>).</li>
                    <li>Hourly weather data for that year (temperature, wind speed, solar radiation).</li>
                    <li>Hourly electricity demand (influenced by temperature).</li>
                    <li>Constraints from the long-term energy model (e.g., total generation from coal over a season must match the NEMS projection).</li>
                    <li>Plant characteristics (operating costs, emission rates, ramp rates - though simplified in this paper's example).</li>
                </ul>
            </li>
            <li><strong>Optimization Goal:</strong> Simulate the decisions of a grid operator trying to meet the hourly electricity demand at the lowest possible cost, given the available power plants and renewable energy generation (which depends directly on the hourly weather).</li>
            <li><strong>Output:</strong> An hourly schedule (dispatch) showing how much electricity each type of power plant generates throughout the year. This hourly generation data is then used to calculate hourly emissions.</li>
        </ol>

        <p>Mathematically, this is often formulated as a constrained optimization problem. While the full formulation involves complex details like transmission constraints, we can think of the basic objective as:</p>
        $$ \min \sum_{t \in \text{Hours}} \sum_{i \in \text{Plants}} (\text{Generation}_{i,t} \times \text{Cost}_{i}) $$
        <p>Subject to constraints like:</p>
        <ul>
            <li>Meeting Demand: $ \sum_{i \in \text{Plants}} \text{Generation}_{i,t} \ge \text{Demand}_t $ for each hour $t$.</li>
            <li>Plant Capacity: $ 0 \le \text{Generation}_{i,t} \le \text{Capacity}_{i,t} $ (Capacity might vary with weather for renewables or thermal plants).</li>
            <li>Renewable Availability: $ \text{Generation}_{\text{solar},t} \le \text{Available Solar}_t $, $ \text{Generation}_{\text{wind},t} \le \text{Available Wind}_t $.</li>
            <li>NEMS Consistency: $ \sum_{t \in \text{Block}} \text{Generation}_{i,t} = \text{NEMS Target}_{i, \text{Block}} $ (Total generation in a NEMS time block matches the target).</li>
            <li>(And others like ramping limits, transmission limits, etc., in more complex models).</li>
        </ul>

        <div class="interactive-visualization card">
            <div class="card-body">
                <h5 class="card-title">Simplified TDM Dispatch Simulation</h5>
                <p class="explanation">This simulates a basic hourly dispatch over a few days. Adjust the solar and wind capacity, and see how the generation mix changes hour by hour. The model tries to use the cheapest available resources (renewables first, then coal, then gas) to meet demand. Notice how the pattern of gas generation (often the flexible 'peaker') changes significantly based on renewable availability, unlike the fixed SMOKE profile.</p>
                <div class="row mb-3">
                    <div class="col-md-6">
                        <label for="tdmSolarSlider" class="form-label slider-label">Solar Capacity (% Peak Load): <span id="tdmSolarValue" class="slider-value">20</span>%</label>
                        <input type="range" class="form-range" id="tdmSolarSlider" min="0" max="80" step="5" value="20">
                    </div>
                    <div class="col-md-6">
                        <label for="tdmWindSlider" class="form-label slider-label">Wind Capacity (% Peak Load): <span id="tdmWindValue" class="slider-value">15</span>%</label>
                        <input type="range" class="form-range" id="tdmWindSlider" min="0" max="80" step="5" value="15">
                    </div>
                </div>
                 <div class="text-center mb-2">
                     <button id="runTdmButton" class="btn btn-primary btn-sm">Run Dispatch Simulation</button>
                 </div>
                <div id="tdm-dispatch-viz"></div>
                <p class="explanation small mt-2">Note: This is a highly simplified 'merit order' dispatch for illustration. Real models involve complex optimization solvers.</p>
            </div>
        </div>

        <h2>Why Timing Matters: TDM vs. SMOKE and Air Quality</h2>

        <p>The key takeaway is that TDM produces hourly emission profiles that are sensitive to the specific future scenario (plant mix, policies) and the weather conditions of that year. SMOKE profiles, being based on historical averages, lack this sensitivity.</p>

        <p>The paper shows this contrast clearly (Figure 4 in the paper). On a hot day with little sun, TDM might show high emissions in the afternoon as gas plants ramp up to meet air conditioning demand. On a cooler, sunny day, TDM might show a dip in emissions midday (the "duck curve" effect) as solar displaces thermal plants, with peaks shifted to the morning and evening. SMOKE, in contrast, tends to produce a similar emission shape every day, often peaking midday regardless of weather or solar output.</p>

        <div class="interactive-visualization card">
            <div class="card-body">
                <h5 class="card-title">TDM vs. SMOKE-like Profile Comparison</h5>
                <p class="explanation">Compare the hourly generation pattern from the TDM simulation (top) with a fixed, SMOKE-like historical profile (bottom) over the same period. The TDM profile adapts dynamically based on the renewable inputs you set above, while the SMOKE-like profile repeats its historical shape.</p>
                <div id="tdm-comparison-viz" class="mb-3"></div>
                <div id="smoke-comparison-viz"></div>
            </div>
        </div>

        <p>This difference is crucial for air quality. For example, the formation of ground-level ozone (a major component of smog) requires Nitrogen Oxides (NOx - emitted by burning fossil fuels) and sunlight, often peaking on hot, sunny afternoons. </p>

        <p>The paper develops a simple "Ozone Formation Potential Index" based on weather (high index = conditions favorable for ozone). It finds that:</p>
        <ul>
            <li><span class="highlight">SMOKE profiles</span> often show high NOx emissions coinciding with high ozone potential conditions (because historical peaks were often midday/afternoon).</li>
            <li><span class="highlight">TDM profiles</span>, in scenarios with significant solar power, often show *lower* NOx emissions during the peak ozone potential hours (midday) because solar energy displaces the fossil fuel plants. The NOx peaks are shifted to the evening ramp when ozone formation potential is lower.</li>
        </ul>

        <p>Relying on SMOKE could therefore overestimate future ozone problems in high-solar scenarios, while TDM provides a potentially more accurate picture by capturing how renewable energy changes the *timing* of emissions.</p>

        <div class="interactive-visualization card">
             <div class="card-body">
                <h5 class="card-title">Emissions Timing and Ozone Potential</h5>
                <p class="explanation">This chart shows hypothetical NOx emissions (derived from the TDM simulation's coal/gas use) and a simple Ozone Formation Potential Index (higher on sunny/calm periods). Compare the TDM emissions timing (reflecting solar displacement) with the fixed SMOKE timing relative to the ozone index peaks. (Requires running the TDM simulation above first).</p>
                <div id="ozone-correlation-viz"></div>
                <p class="explanation small mt-2">Note: Assumes simple NOx rates: Gas = 0.5 units/MWh, Coal = 1 unit/MWh. Ozone index is illustrative based on simulated solar/wind availability.</p>
            </div>
        </div>


        <h2>Scenario Differences and Conclusions</h2>

        <p>Furthermore, the TDM approach allows us to see how different future energy pathways affect hourly emissions. The paper examined scenarios like high natural gas use, high electric vehicle adoption, and high energy efficiency. TDM produced distinct hourly emission patterns for each, reflecting how the different system compositions and demands change optimal grid operations. SMOKE profiles, being largely fixed, showed much less variation between scenarios beyond simple scaling.</p>

        <p>In conclusion, the Temporal Downscaling Method (TDM) offers a more sophisticated way to link long-term energy scenarios with hourly air quality modeling needs. By simulating the <strong>operational realities</strong> of future power grids, including the crucial interplay between weather, renewable energy, and demand, TDM provides:</p>
        <ul>
            <li>More realistic hourly emission profiles.</li>
            <li>Better representation of how emissions timing changes with high renewable penetration.</li>
            <li>Improved ability to assess the air quality impacts of different energy transition pathways and policies.</li>
        </ul>

        <p>While more complex than traditional methods, this fundamentals-based approach is vital for accurately understanding the environmental and health consequences of our evolving energy future.</p>

    </div>

    <!-- Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Custom JS for visualizations -->
    <script>
        // Common visualization settings
        const margin = {top: 20, right: 30, bottom: 40, left: 50};
        const defaultWidth = 850; // Adjusted for container
        const defaultHeight = 250;

        // --- Visualization 1: SMOKE Profile ---
        function drawSmokeViz(scaleFactor) {
            d3.select("#smoke-viz").selectAll("*").remove(); // Clear previous viz

            const width = defaultWidth - margin.left - margin.right;
            const height = defaultHeight - margin.top - margin.bottom;

            const svg = d3.select("#smoke-viz")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Sample historical daily pattern (arbitrary shape)
            const hours = d3.range(0, 24);
            const historicalPattern = [0.5, 0.5, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.2, 1.3, 1.4, 1.5, 1.6, 1.6, 1.5, 1.4, 1.2, 1.0, 0.9, 0.8, 0.7, 0.6];
            const data = hours.map(h => ({ hour: h, value: historicalPattern[h] * scaleFactor }));

            // Scales
            const xScale = d3.scaleLinear()
                .domain([0, 23])
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(historicalPattern) * 2.5]) // Fixed max scale for comparison
                .range([height, 0]);

            // Axes
            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale).ticks(24));
            svg.append("g")
                .call(d3.axisLeft(yScale));

            // Line
            svg.append("path")
                .datum(data)
                .attr("class", "line")
                .attr("stroke", "steelblue")
                .attr("d", d3.line()
                    .x(d => xScale(d.hour))
                    .y(d => yScale(d.value))
                    .curve(d3.curveMonotoneX)
                );

            // Labels
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 5)
                .text("Hour of Day");

            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 15)
                .text("Relative Emission Rate");
        }

        const smokeScaleSlider = d3.select("#smokeScaleSlider");
        smokeScaleSlider.on("input", function() {
            const scale = +this.value;
            d3.select("#smokeScaleValue").text(scale.toFixed(1));
            drawSmokeViz(scale);
        });
        drawSmokeViz(1.0); // Initial draw


        // --- Visualization 2: Duck Curve ---
        function drawDuckCurveViz(solarCapacityPercent) {
            d3.select("#duck-curve-viz").selectAll("*").remove();

            const width = defaultWidth - margin.left - margin.right;
            const height = defaultHeight - margin.top - margin.bottom;

            const svg = d3.select("#duck-curve-viz")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Sample daily data
            const hours = d3.range(0, 24);
            // Simple gross load profile (arbitrary units)
            const grossLoadProfile = [60, 58, 57, 56, 57, 60, 65, 75, 85, 90, 92, 93, 94, 95, 98, 100, 105, 110, 105, 95, 85, 75, 70, 65];
            // Simple solar generation profile (capacity factor * peak capacity)
            const solarCF = [0, 0, 0, 0, 0, 0.1, 0.3, 0.5, 0.7, 0.85, 0.95, 1.0, 0.95, 0.85, 0.7, 0.5, 0.3, 0.1, 0, 0, 0, 0, 0, 0];
            const peakLoad = d3.max(grossLoadProfile);
            const solarCapacity = peakLoad * (solarCapacityPercent / 100);

            const data = hours.map(h => {
                const gross = grossLoadProfile[h];
                const solarGen = solarCF[h] * solarCapacity;
                const net = gross - solarGen;
                return { hour: h, gross: gross, solar: solarGen, net: net };
            });

            // Scales
            const xScale = d3.scaleLinear().domain([0, 23]).range([0, width]);
            const yScale = d3.scaleLinear().domain([0, peakLoad * 1.1]).range([height, 0]); // Extend y-axis slightly

            // Axes
            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale).ticks(24));
            svg.append("g")
                .call(d3.axisLeft(yScale));

            // Lines
            const lineGen = d3.line()
                .x(d => xScale(d.hour))
                .curve(d3.curveMonotoneX);

            svg.append("path") // Gross Load
                .datum(data)
                .attr("class", "line")
                .attr("stroke", "grey")
                .attr("d", lineGen.y(d => yScale(d.gross)));

            svg.append("path") // Solar Generation
                .datum(data)
                .attr("class", "line")
                .attr("stroke", "orange")
                .attr("d", lineGen.y(d => yScale(d.solar)));

            svg.append("path") // Net Load (Duck Curve)
                .datum(data)
                .attr("class", "line")
                .attr("stroke", "blue")
                .style("stroke-width", "3px")
                .attr("d", lineGen.y(d => yScale(d.net)));

             // Labels & Legend
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 5)
                .text("Hour of Day");

            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 15)
                .text("Load / Generation");

            const legend = svg.append("g")
                .attr("transform", `translate(${width - 100}, 0)`);

            legend.append("rect").attr("width", 15).attr("height", 2).attr("fill", "grey").attr("y", 0);
            legend.append("text").text("Gross Load").attr("x", 20).attr("y", 5).style("font-size", "10px");
            legend.append("rect").attr("width", 15).attr("height", 2).attr("fill", "orange").attr("y", 15);
            legend.append("text").text("Solar Gen").attr("x", 20).attr("y", 20).style("font-size", "10px");
            legend.append("rect").attr("width", 15).attr("height", 3).attr("fill", "blue").attr("y", 30);
            legend.append("text").text("Net Load").attr("x", 20).attr("y", 35).style("font-size", "10px").style("font-weight", "bold");
        }

        const solarCapacitySlider = d3.select("#solarCapacitySlider");
        solarCapacitySlider.on("input", function() {
            const capacity = +this.value;
            d3.select("#solarCapacityValue").text(capacity);
            drawDuckCurveViz(capacity);
        });
        drawDuckCurveViz(0); // Initial draw

        // --- Visualization 3: TDM Dispatch Simulation ---
        let tdmDispatchData = null; // To store simulation results
        let tdmComparisonData = null; // To store data for comparison viz

        function runTdmSimulation() {
            const solarCapacityPercent = +d3.select("#tdmSolarSlider").property("value");
            const windCapacityPercent = +d3.select("#tdmWindSlider").property("value");

            // Define sample plant characteristics (simplified)
            // Costs are arbitrary units/MWh
            const plants = [
                { name: "Solar", type: "Solar", capacityFactorData: [0,0,0,0,0,0.1,0.3,0.5,0.7,0.85,0.95,1.0,0.95,0.85,0.7,0.5,0.3,0.1,0,0,0,0,0,0], cost: 0 },
                { name: "Wind", type: "Wind", capacityFactorData: [0.4,0.45,0.5,0.55,0.5,0.45,0.4,0.35,0.3,0.3,0.3,0.35,0.4,0.45,0.5,0.5,0.45,0.4,0.4,0.45,0.5,0.5,0.45,0.4], cost: 0 },
                { name: "Coal", type: "Coal", capacityFactorData: Array(24).fill(1), cost: 30 }, // Baseload-ish cost
                { name: "Gas", type: "Gas", capacityFactorData: Array(24).fill(1), cost: 60 } // Peaker cost
                // Add Nuclear later if needed: { name: "Nuclear", type: "Nuclear", capacityFactorData: Array(24).fill(0.9), cost: 10 } // Baseload
            ];

            // Sample hourly demand over 3 days (72 hours)
            const hoursTotal = 72;
            const dailyDemandProfile = [60, 58, 57, 56, 57, 60, 65, 75, 85, 90, 92, 93, 94, 95, 98, 100, 105, 110, 105, 95, 85, 75, 70, 65];
            const demandData = [];
            for (let i = 0; i < hoursTotal; i++) {
                demandData.push(dailyDemandProfile[i % 24]);
            }
            const peakLoad = d3.max(demandData);

            // Assign capacities based on sliders (% of peak load)
            // Simplified fixed capacities for thermal for this example
            const totalCapacity = peakLoad * 1.5; // Assume total capacity is 150% of peak load
            const solarCapacity = peakLoad * (solarCapacityPercent / 100);
            const windCapacity = peakLoad * (windCapacityPercent / 100);
            const thermalCapacity = totalCapacity - solarCapacity - windCapacity;
            // Split thermal capacity (e.g., 60% Coal, 40% Gas - arbitrary)
            const coalCapacity = thermalCapacity * 0.6;
            const gasCapacity = thermalCapacity * 0.4;

            plants.find(p => p.type === 'Solar').capacity = solarCapacity;
            plants.find(p => p.type === 'Wind').capacity = windCapacity;
            plants.find(p => p.type === 'Coal').capacity = coalCapacity;
            plants.find(p => p.type === 'Gas').capacity = gasCapacity;

            // Sort plants by cost (merit order)
            const sortedPlants = [...plants].sort((a, b) => a.cost - b.cost);

            // --- Simplified Dispatch Logic ---
            const hourlyGeneration = []; // { hour: h, Solar: genS, Wind: genW, Coal: genC, Gas: genG }
            for (let h = 0; h < hoursTotal; h++) {
                let remainingDemand = demandData[h];
                const generation = { hour: h };

                // Dispatch each plant type
                for (const plant of sortedPlants) {
                    const hourlyCF = plant.capacityFactorData[h % 24];
                    const availableCapacity = plant.capacity * hourlyCF;
                    let dispatchAmount = 0;

                    if (remainingDemand > 0 && availableCapacity > 0) {
                        dispatchAmount = Math.min(remainingDemand, availableCapacity);
                        generation[plant.type] = dispatchAmount;
                        remainingDemand -= dispatchAmount;
                    } else {
                        generation[plant.type] = 0; // Ensure all types are present
                    }
                }
                // Handle unmet demand (optional - could show as shortage)
                if (remainingDemand > 0.1) { // Use small tolerance
                    // console.warn(`Hour ${h}: Unmet demand of ${remainingDemand.toFixed(1)}`);
                    generation['Unmet'] = remainingDemand; // Track unmet demand
                } else {
                     generation['Unmet'] = 0;
                }

                hourlyGeneration.push(generation);
            }
            // --- End Dispatch Logic ---

            tdmDispatchData = hourlyGeneration; // Store for visualization
            tdmComparisonData = hourlyGeneration.map(d => ({hour: d.hour, value: d.Coal + d.Gas})); // Store thermal for comparison viz

            drawTdmDispatchViz(tdmDispatchData, plants); // Draw the main TDM viz
            drawComparisonViz(); // Update comparison viz
            drawOzoneCorrelationViz(); // Update ozone viz
        }

        function drawTdmDispatchViz(data, plantInfo) {
            if (!data) return; // Don't draw if no data

            d3.select("#tdm-dispatch-viz").selectAll("*").remove();

            const width = defaultWidth - margin.left - margin.right;
            const height = defaultHeight - margin.top - margin.bottom;

            const svg = d3.select("#tdm-dispatch-viz")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const keys = plantInfo.map(p => p.type).filter(type => type !== 'Unmet'); // Stackable types
            const colors = { Solar: "orange", Wind: "lightblue", Coal: "black", Gas: "red" }; // Nuclear: "green"

            // Stack the data
            const stack = d3.stack().keys(keys);
            const stackedData = stack(data);

            // Scales
            const xScale = d3.scaleLinear().domain([0, data.length - 1]).range([0, width]);
            const yScale = d3.scaleLinear().domain([0, d3.max(data, d => d3.sum(keys, key => d[key])) * 1.1]).range([height, 0]); // Max of total generation

            // Axes
            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale).ticks(data.length / 6)); // Ticks every 6 hours
            svg.append("g")
                .call(d3.axisLeft(yScale));

            // Area generator
            const areaGen = d3.area()
                .x(d => xScale(d.data.hour))
                .y0(d => yScale(d[0]))
                .y1(d => yScale(d[1]))
                .curve(d3.curveBasis); // Smoother curve

            // Draw areas
            svg.append("g")
                .selectAll("path")
                .data(stackedData)
                .join("path")
                .attr("class", "area")
                .attr("fill", d => colors[d.key] || 'grey')
                .attr("d", areaGen);

            // Labels & Legend
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 5)
                .text("Hour of Simulation");

            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 15)
                .text("Generation");

            const legend = svg.append("g")
                .attr("transform", `translate(${width - 80}, 0)`);

            keys.forEach((key, i) => {
                legend.append("rect").attr("width", 15).attr("height", 10).attr("fill", colors[key]).attr("y", i * 15);
                legend.append("text").text(key).attr("x", 20).attr("y", i * 15 + 9).style("font-size", "10px");
            });
        }

        // Event listeners for TDM sliders and button
        const tdmSolarSlider = d3.select("#tdmSolarSlider");
        const tdmWindSlider = d3.select("#tdmWindSlider");
        const runTdmButton = d3.select("#runTdmButton");

        tdmSolarSlider.on("input", function() {
            d3.select("#tdmSolarValue").text(this.value);
        });
        tdmWindSlider.on("input", function() {
             d3.select("#tdmWindValue").text(this.value);
        });
        runTdmButton.on("click", runTdmSimulation);

        // Initial simulation run
        runTdmSimulation();


        // --- Visualization 4: TDM vs SMOKE Comparison ---
        function drawComparisonViz() {
            // Draw TDM part (Thermal only)
             d3.select("#tdm-comparison-viz").selectAll("*").remove();
             if (!tdmComparisonData) return;

             const width = defaultWidth - margin.left - margin.right;
             const height = 120 - margin.top - margin.bottom; // Smaller height

             const svgTDM = d3.select("#tdm-comparison-viz")
                 .append("svg")
                 .attr("width", width + margin.left + margin.right)
                 .attr("height", height + margin.top + margin.bottom)
                 .append("g")
                 .attr("transform", `translate(${margin.left},${margin.top})`);

             const xScale = d3.scaleLinear().domain([0, tdmComparisonData.length - 1]).range([0, width]);
             const yScaleTDM = d3.scaleLinear().domain([0, d3.max(tdmComparisonData, d => d.value) * 1.1]).range([height, 0]);

             svgTDM.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale).ticks(tdmComparisonData.length / 6));
             svgTDM.append("g").call(d3.axisLeft(yScaleTDM).ticks(3));

             svgTDM.append("path")
                 .datum(tdmComparisonData)
                 .attr("class", "line")
                 .attr("stroke", "purple")
                 .attr("d", d3.line()
                     .x(d => xScale(d.hour))
                     .y(d => yScaleTDM(d.value))
                     .curve(d3.curveBasis)
                 );
            svgTDM.append("text").text("TDM Thermal Generation").attr("x", 10).attr("y", 0).style("font-size", "10px").style("font-weight", "bold");


            // Draw SMOKE part (Fixed profile scaled)
            d3.select("#smoke-comparison-viz").selectAll("*").remove();
            const svgSMOKE = d3.select("#smoke-comparison-viz")
                 .append("svg")
                 .attr("width", width + margin.left + margin.right)
                 .attr("height", height + margin.top + margin.bottom)
                 .append("g")
                 .attr("transform", `translate(${margin.left},${margin.top})`);

            const smokePattern = [0.5, 0.5, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.2, 1.3, 1.4, 1.5, 1.6, 1.6, 1.5, 1.4, 1.2, 1.0, 0.9, 0.8, 0.7, 0.6];
            const avgTdmThermal = d3.mean(tdmComparisonData, d => d.value);
            const avgSmokePattern = d3.mean(smokePattern);
            const smokeScale = avgTdmThermal / avgSmokePattern || 1; // Scale to match average TDM thermal

            const smokeCompData = [];
            for (let h = 0; h < tdmComparisonData.length; h++) {
                smokeCompData.push({ hour: h, value: smokePattern[h % 24] * smokeScale });
            }

            const yScaleSMOKE = d3.scaleLinear().domain([0, d3.max(smokeCompData, d => d.value) * 1.1]).range([height, 0]);

            svgSMOKE.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale).ticks(tdmComparisonData.length / 6));
            svgSMOKE.append("g").call(d3.axisLeft(yScaleSMOKE).ticks(3));

            svgSMOKE.append("path")
                 .datum(smokeCompData)
                 .attr("class", "line")
                 .attr("stroke", "steelblue")
                 .attr("d", d3.line()
                     .x(d => xScale(d.hour))
                     .y(d => yScaleSMOKE(d.value))
                     .curve(d3.curveBasis) // Use same curve for visual consistency
                 );
            svgSMOKE.append("text").text("SMOKE-like Profile (Scaled)").attr("x", 10).attr("y", 0).style("font-size", "10px").style("font-weight", "bold");

             // Common X axis label
             svgSMOKE.append("text")
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 5)
                .text("Hour of Simulation");
        }


        // --- Visualization 5: Ozone Correlation ---
        function drawOzoneCorrelationViz() {
            d3.select("#ozone-correlation-viz").selectAll("*").remove();
            if (!tdmDispatchData) return;

            const width = defaultWidth - margin.left - margin.right;
            const height = defaultHeight - margin.top - margin.bottom;

            const svg = d3.select("#ozone-correlation-viz")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Calculate NOx and Ozone Index
            const noxRateCoal = 1.0; // Arbitrary units/MWh
            const noxRateGas = 0.5;  // Arbitrary units/MWh
            const smokePattern = [0.5, 0.5, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.2, 1.3, 1.4, 1.5, 1.6, 1.6, 1.5, 1.4, 1.2, 1.0, 0.9, 0.8, 0.7, 0.6]; // Reuse pattern

            let totalTdmNox = 0;
            const plotData = tdmDispatchData.map(d => {
                const tdmNox = (d.Coal * noxRateCoal) + (d.Gas * noxRateGas);
                totalTdmNox += tdmNox;
                // Simple Ozone Index: Higher when solar is high (sun) and wind is low (stagnant)
                const solarCF = d.Solar > 0 ? d.Solar / +d3.select("#tdmSolarSlider").property("value") / (d3.max(demandData) / 100) : 0; // Approx CF
                const windCF = d.Wind > 0 ? d.Wind / +d3.select("#tdmWindSlider").property("value") / (d3.max(demandData) / 100) : 0; // Approx CF
                const ozoneIndex = Math.max(0, (solarCF * 0.7 + (1 - windCF) * 0.3)); // Weighted, arbitrary scale 0-1
                return { hour: d.hour, tdmNox: tdmNox, ozoneIndex: ozoneIndex };
            });

            // Scale SMOKE NOx to match total TDM NOx
            let totalSmokePatternNox = 0;
            const smokeRefData = [];
             for(let h=0; h<plotData.length; h++) {
                 smokeRefData.push(smokePattern[h%24]);
                 totalSmokePatternNox += smokePattern[h%24];
             }
            const smokeNoxScale = totalTdmNox / totalSmokePatternNox || 1;
            plotData.forEach((d, i) => {
                d.smokeNox = smokeRefData[i] * smokeNoxScale;
            });


            // Scales
            const xScale = d3.scaleLinear().domain([0, plotData.length - 1]).range([0, width]);
            const yNoxScale = d3.scaleLinear().domain([0, d3.max(plotData, d => Math.max(d.tdmNox, d.smokeNox)) * 1.1]).range([height, 0]);
            const yOzoneScale = d3.scaleLinear().domain([0, 1]).range([height, 0]); // Ozone Index 0-1

            // Axes
            svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale).ticks(plotData.length / 6));
            // Left Axis (NOx)
            svg.append("g").call(d3.axisLeft(yNoxScale).ticks(5));
            svg.append("text").attr("text-anchor", "middle").attr("transform", "rotate(-90)")