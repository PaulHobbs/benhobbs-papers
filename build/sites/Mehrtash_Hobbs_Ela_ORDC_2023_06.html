<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Understanding Reserve Scarcity Pricing in Power Markets</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- MathJax Configuration -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
        };
      </script>
    <!-- MathJax Library -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>
    <!-- D3.js Library -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            padding-bottom: 50px; /* Footer space */
        }
        .container {
            max-width: 900px; /* Limit width for readability */
        }
        h1, h2, h3 {
            margin-top: 1.5em;
            margin-bottom: 0.8em;
            font-weight: 300;
        }
        h1 { font-size: 2.5em; }
        h2 { font-size: 1.8em; border-bottom: 1px solid #eee; padding-bottom: 0.3em;}
        h3 { font-size: 1.4em; }
        p, li {
            font-size: 1.05em;
        }
        code {
            background-color: #f0f0f0;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .interactive-visualization {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 20px;
            margin-top: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .slider-label {
            font-size: 0.9em;
            color: #555;
            margin-bottom: 0;
        }
        .value-display {
            font-weight: bold;
            color: #007bff;
            min-width: 50px;
            display: inline-block;
            text-align: right;
        }
        .axis path,
        .axis line {
          fill: none;
          stroke: #000;
          shape-rendering: crispEdges;
        }
        .axis text {
          font-size: 11px;
        }
        .grid line {
          stroke: lightgrey;
          stroke-opacity: 0.7;
          shape-rendering: crispEdges;
        }
        .grid path {
          stroke-width: 0;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            width: auto;
            height: auto;
            padding: 5px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
        }
        /* Custom styles for specific charts if needed */
        #ordc-basic-chart .line {
            fill: none;
            stroke: steelblue;
            stroke-width: 3px;
        }
        #ordc-basic-chart .reserve-marker {
            fill: red;
            stroke: darkred;
            stroke-width: 1px;
        }
         #comparative-chart .line {
            fill: none;
            stroke-width: 2.5px;
            opacity: 0.8;
        }

    </style>
</head>
<body>
    <div class="container mt-4">

        <h1>Keeping the Lights On: When Electricity Gets Scarce</h1>
        <p class="lead">Exploring how power grid operators handle shortages using "Scarcity Pricing", based on the paper <a href="https://doi.org/10.1016/j.rser.2023.113465" target="_blank">"Reserve and energy scarcity pricing in United States power markets: A comparative review of principles and practices"</a> by Mehrtash, Hobbs, and Ela.</p>

        <p>Imagine the electric grid as a giant, complex balancing act. At every single moment, the amount of electricity generated must exactly match the amount consumed. If there's too little power, you get blackouts. Too much, and equipment can be damaged. Grid operators work constantly to maintain this balance.</p>

        <p>But what happens when things go wrong? A power plant might unexpectedly shut down. Demand might surge during a heatwave. Clouds might suddenly block the sun, reducing solar power output. To handle these surprises, grid operators keep some power plants ready in reserve, like a spare tire for your car. This backup is called <a href="https://en.wikipedia.org/wiki/Operating_reserve" target="_blank">Operating Reserve</a>.</p>

        <p>When these reserves start running low, the grid is in a state of <strong>scarcity</strong>. It's a warning sign that the system is stressed and blackouts are more likely. How should the electricity market react? This is where <strong>Scarcity Pricing</strong> comes in. It's a way for grid operators to signal this scarcity by administratively increasing the price of electricity and reserves. These higher prices encourage generators to produce more power (if possible) and motivate large consumers to use less electricity.</p>

        <p>Different regions in the U.S. have different ways of implementing scarcity pricing. With the rise of renewable energy sources like wind and solar (which have near-zero fuel costs), these administrative scarcity prices are becoming increasingly important for setting market prices and ensuring the grid remains reliable. This post explores the core ideas and differences in these approaches, using interactive visualizations to build intuition.</p>

        <!-- Section: What are Reserves and ORDCs? -->
        <h2>The Foundation: Reserves and Demand Curves</h2>

        <p>Operating reserves are crucial for reliability. They come in different flavors, based on how quickly they can respond:</p>
        <ul>
            <li><strong>Regulation Reserves:</strong> Respond within seconds to minor fluctuations.</li>
            <li><strong>Spinning Reserves:</strong> Synchronized to the grid, ready to ramp up energy output within 10 minutes.</li>
            <li><strong>Non-Spinning Reserves:</strong> Can be started and ramped up within 10 minutes.</li>
            <li><strong>Flexiramp (Newer):</strong> Specifically designed to handle the rapid changes in output from wind and solar power over short periods (e.g., 5-15 minutes).</li>
        </ul>

        <p>When reserves are plentiful, their "value" in the market might be low â€“ just the cost of having a power plant ready but not producing much energy. But as the amount of available reserves dwindles, the risk to the grid increases. The "value" of that last remaining megawatt (MW) of reserve becomes much higher because it might be the only thing preventing a blackout.</p>

        <p>Market designers represent this changing value using an <strong>Operating Reserve Demand Curve (ORDC)</strong>. It's not a demand curve in the traditional sense (consumers deciding how much to buy), but rather an <strong>administrative</strong> curve set by the grid operator. It defines the price (or penalty) the system is willing to pay for reserves based on how much is available.</p>

        <p>Here's a simplified, conceptual ORDC. Drag the slider to change the amount of available reserves and see how the "scarcity price" changes. Notice that as reserves get very low, the price shoots up dramatically.</p>

        <div class="interactive-visualization">
            <h4>Interactive ORDC Concept</h4>
            <p class="slider-label">Available Reserves (MW): <span id="reserve-level-display" class="value-display">1500</span> MW</p>
            <input type="range" class="form-range" id="reserve-level-slider" min="0" max="3000" value="1500" step="10">
            <div id="ordc-basic-chart"></div>
            <p class="mt-2">Scarcity Price: $<span id="scarcity-price-display" class="value-display">0</span> / MWh</p>
            <small>This is a conceptual illustration. Real ORDCs have specific shapes and steps defined by market rules.</small>
        </div>

        <!-- Section: How ISOs Implement Scarcity Pricing -->
        <h2>Apples and Oranges: Different Approaches to Scarcity Pricing</h2>

        <p>The paper groups the methods used by U.S. <a href="https://en.wikipedia.org/wiki/Independent_system_operator_and_regional_transmission_organization" target="_blank">Independent System Operators (ISOs)</a> / Regional Transmission Organizations (RTOs) into three main categories:</p>

        <h3>1. The Ex Post Adder (ERCOT - Texas)</h3>
        <p>Texas (ERCOT) uses a unique approach. They run their main real-time energy market first *without* explicitly including reserve demand curves. After the market clears and energy prices (Locational Marginal Prices, or LMPs) are determined based on generator offers, they calculate a separate <strong>Price Adder</strong>. This adder reflects the scarcity level and is added *on top* of the energy LMP.</p>

        <p>The adder calculation is based on two key concepts:</p>
        <ul>
            <li><strong>Value of Lost Load (VOLL):</strong> An administratively determined estimate of the economic cost consumers bear if their power is cut off (e.g., $5000 per Megawatt-hour). This represents the maximum price the system is willing to pay.</li>
            <li><strong>Loss of Load Probability (LOLP):</strong> The estimated probability, based on forecasts and historical data, that the available generation and reserves will be insufficient to meet demand in the near future. This probability increases as available reserves decrease.</li>
        </ul>

        <p>Roughly speaking, the adder is calculated as: $Adder \approx LOLP \times (VOLL - Energy LMP)$. As reserves ($R$) decrease, $LOLP$ increases, pushing the adder up towards the $VOLL$. If reserves fall below a critical threshold ($R_{req}$), the adder jumps straight to $VOLL - Energy LMP$.</p>

        <div class="interactive-visualization">
            <h4>ERCOT-Style Price Adder Simulation</h4>
            <div class="row">
                <div class="col-md-6">
                    <p class="slider-label">Available Reserves ($R_{sns}$): <span id="ercot-reserve-display" class="value-display">4000</span> MW</p>
                    <input type="range" class="form-range" id="ercot-reserve-slider" min="2000" max="6000" value="4000" step="10">
                </div>
                <div class="col-md-6">
                    <p class="slider-label">Value of Lost Load (VOLL): $<span id="ercot-voll-display" class="value-display">5000</span> / MWh</p>
                    <input type="range" class="form-range" id="ercot-voll-slider" min="1000" max="9000" value="5000" step="100">
                </div>
            </div>
             <div class="row">
                 <div class="col-md-6">
                    <p class="slider-label">Minimum Reserve Req ($R_{req}$): <span id="ercot-rreq-display" class="value-display">3000</span> MW</p>
                     <input type="range" class="form-range" id="ercot-rreq-slider" min="2000" max="4000" value="3000" step="50">
                 </div>
                  <div class="col-md-6">
                     <p class="slider-label">Base Energy LMP ($\lambda$): $<span id="ercot-lmp-display" class="value-display">50</span> / MWh</p>
                      <input type="range" class="form-range" id="ercot-lmp-slider" min="0" max="500" value="50" step="5">
                  </div>
             </div>
            <div id="ercot-adder-chart"></div>
            <p class="mt-2">Calculated Adder: $<span id="ercot-adder-value" class="value-display">0</span> / MWh</p>
            <p>Final Energy Price (LMP + Adder): $<span id="ercot-final-price" class="value-display">50</span> / MWh</p>
            <small>Note: The LOLP calculation uses a simplified curve shape for illustration, based roughly on Fig 1 & 2 from the paper. Real calculations involve probability distributions of forecast errors.</small>
        </div>

        <h3>2. Co-optimized Stepwise ORDCs (Most Other ISOs)</h3>
        <p>Most other ISOs (like PJM, MISO, CAISO, NYISO, ISO-NE, SPP) use a different approach. They <strong>co-optimize</strong> energy and reserves simultaneously. This means the market clearing process considers both the cost of producing energy *and* the value of holding reserves at the same time. They achieve this by building <strong>stepwise ORDCs</strong> directly into the market model.</p>

        <p>These ORDCs typically have several steps. At high reserve levels, the penalty (price) is low. As reserves decrease past certain thresholds, the penalty jumps up in steps. The highest step usually corresponds to a maximum penalty value (often related to the energy offer cap, e.g., $1000/MWh or $2000/MWh, though sometimes higher like MISO's $3500/MWh).</p>

        <div class="interactive-visualization">
            <h4>Stepwise ORDC Concept</h4>
             <p class="slider-label">Available Reserves (MW): <span id="step-reserve-display" class="value-display">3500</span> MW</p>
            <input type="range" class="form-range" id="step-reserve-slider" min="0" max="4000" value="3500" step="10">
            <div id="step-ordc-chart"></div>
            <p class="mt-2">Scarcity Price (Penalty): $<span id="step-penalty-display" class="value-display">0</span> / MWh</p>
            <small>This example shows a generic 3-step ORDC. Real ISOs have varying numbers of steps, prices, and quantities based on their specific rules (see Table 1 in the paper).</small>
        </div>

        <p>A key feature in these co-optimized markets is <strong>nesting</strong>. This means higher-quality, faster-responding reserves (like Regulation or Spinning) can also satisfy the requirements for lower-quality reserves (like Non-Spinning or 30-minute reserves). If there's a shortage of, say, Non-Spinning reserve, the market might use more expensive Spinning reserve to fill the gap. This causes the scarcity price for Non-Spinning to effectively "add up" with the price for Spinning, leading to potentially very high prices for the highest-quality reserves during severe shortages.</p>

        <h4>Sub-flavors: With vs. Without Flexiramp</h4>
        <p>The paper further divides the stepwise ORDC approach based on whether the market includes the newer <strong>Flexiramp</strong> product:</p>
        <ul>
            <li><strong>With Flexiramp (MISO, SPP, CAISO):</strong> These markets explicitly procure reserves to handle short-term ramps. Because flexiramp is often needed even when traditional reserves aren't critically low (e.g., to handle solar ramp-downs), including it tends to create scarcity prices more often and extends the "right tail" of the energy scarcity premium curve (meaning prices start rising at higher levels of overall reserve availability). The penalties for flexiramp shortages are often lower than for contingency reserves, based on different rationales (e.g., cost of starting a fast generator, or just avoiding leaning on neighbors).</li>
            <li><strong>Without Flexiramp (NYISO, PJM, ISO-NE):</strong> These markets rely on traditional contingency reserves (spin, non-spin, 30-min) and regulation. Their scarcity price curves tend to have shorter right tails, primarily activating during contingency events or more severe shortages.</li>
        </ul>


        <!-- Section: Comparative Example -->
        <h2>Putting It All Together: A Comparative Simulation</h2>

        <p>The different assumptions and methods used by ISOs lead to significantly different scarcity prices under the same physical conditions. The paper presents a numerical example (Section 4) to illustrate this. Let's explore a simplified, interactive version inspired by Figure 11.</p>

        <p>Imagine a system with 50 GW of generation capacity facing a 40 GW load. This leaves 10 GW of potential reserves. However, let's assume a minimum contingency reserve requirement of 3 GW must always be met. The chart below shows how the scarcity premium added to the energy price might vary as the *actual* available reserves (total capacity minus load) change, according to the rules of different ISOs.</p>

        <p>Use the dropdown menu to select different ISO approaches and drag the slider to see how the scarcity premium changes. Notice the differences in:</p>
        <ul>
            <li>The maximum price reached during severe scarcity (0-3 GW available).</li>
            <li>How quickly the price increases as reserves decrease (the slope).</li>
            *   How far the "right tail" extends (at what reserve level prices start to rise above zero).</li>
        </ul>

        <div class="interactive-visualization">
            <h4>Comparative Scarcity Premiums (Inspired by Fig. 11)</h4>
            <div class="row mb-3">
                 <div class="col-md-6">
                     <label for="iso-select" class="form-label slider-label">Select ISO Approach:</label>
                     <select id="iso-select" class="form-select form-select-sm">
                         <option value="ERCOT" selected>ERCOT (Adder)</option>
                         <option value="PJM">PJM (Steps, No Flex)</option>
                         <option value="CAISO">CAISO (Steps, Flex)</option>
                         <option value="NYISO">NYISO (Steps, No Flex)</option>
                         <option value="SPP">SPP (Steps, Flex)</option>
                         <option value="ISO-NE">ISO-NE (Steps, No Flex)</option>
                         <option value="MISO">MISO (Steps, Flex)</option>
                         <option value="ALL">Show All</option>
                     </select>
                 </div>
                 <div class="col-md-6">
                    <p class="slider-label mb-0">Available Reserves (GW): <span id="compare-reserve-display" class="value-display">7.0</span> GW</p>
                    <input type="range" class="form-range" id="compare-reserve-slider" min="0" max="10" value="7" step="0.1">
                 </div>
             </div>
             <div id="comparative-chart"></div>
             <p class="mt-2">Selected ISO Premium: $<span id="compare-premium-display" class="value-display">0</span> / MWh</p>
             <small>Note: Curves are based on simplified interpretations of ISO rules described in the paper and its Table 1/Section 4 assumptions (e.g., 3 GW min contingency reserve, $50/MWh base LMP, $1000 or $2000 offer caps where applicable, VOLL=$5000 for ERCOT, simplified flexiramp effects). Nesting effects are included by summing relevant penalties. Actual prices are highly situation-dependent.</small>
        </div>

        <p>As the simulation shows, ERCOT's VOLL-based adder leads to the highest prices during extreme scarcity. CAISO, with a lower energy offer cap (in the base case scenario), shows lower peak prices. Markets with flexiramp (CAISO, SPP, MISO) tend to show prices rising earlier (longer right tail) compared to those without (PJM, NYISO, ISO-NE). The exact shapes and step locations vary significantly based on each ISO's specific parameter choices.</p>

        <!-- Section: Sensitivity and Conclusions -->
        <h2>Why Do They Differ So Much? And What Makes a Good ORDC?</h2>

        <p>The paper's sensitivity analysis (Section 4.3) confirms what the comparison suggests: the biggest driver of differences between the ORDCs is the <strong>penalty level chosen for severe scarcity</strong> (e.g., the VOLL or the highest penalty step). The number and size of the steps, and whether flexiramp is included, also play significant roles.</p>

        <p>So, what makes a "good" scarcity pricing mechanism? The authors conclude that an effective ORDC should ideally have three features:</p>
        <ol>
            <li><strong>Reflect Marginal Value:</strong> The penalty/price should increase as shortages become more severe, reflecting the rising marginal value of reserves in preventing blackouts.</li>
            <li><strong>Consider Probabilities:</strong> The calculation should incorporate the likelihood (probability) and magnitude of potential contingencies (like generator outages or forecast errors).</li>
            <li><strong>Avoid Abrupt Discontinuities:</strong> Smooth curves (like ERCOT's adder) or many small steps are generally preferable to large, abrupt jumps in price, which can cause excessive market volatility unrelated to fundamental changes in conditions.</li>
        </ol>

        <p>Getting scarcity pricing right is crucial. As our grid relies more on variable renewables, these mechanisms will increasingly determine not just reliability, but also the economic signals for investment in new generation, storage, and demand response. The significant differences across U.S. markets highlight an ongoing evolution in market design, striving to balance reliability and economic efficiency in a changing power system.</p>

    </div>

    <!-- Footer -->
    <footer class="text-center mt-5 text-muted">
        <small>Interactive explanation by AI, inspired by Mehrtash, Hobbs, Ela (2023). For educational purposes only.</small>
    </footer>

    <!-- Bootstrap JS Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Inline Javascript for visualizations -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {

        // --- Visualization 1: Basic ORDC Concept ---
        const reserveSlider = document.getElementById('reserve-level-slider');
        const reserveDisplay = document.getElementById('reserve-level-display');
        const priceDisplay = document.getElementById('scarcity-price-display');
        const orcdBasicSvg = d3.select("#ordc-basic-chart").append("svg")
            .attr("width", "100%")
            .attr("height", 200);
        const orcdBasicMargin = {top: 20, right: 30, bottom: 30, left: 50};
        const orcdBasicWidth = orcdBasicSvg.node().getBoundingClientRect().width - orcdBasicMargin.left - orcdBasicMargin.right;
        const orcdBasicHeight = 200 - orcdBasicMargin.top - orcdBasicMargin.bottom;

        const orcdBasicX = d3.scaleLinear().range([0, orcdBasicWidth]);
        const orcdBasicY = d3.scaleLinear().range([orcdBasicHeight, 0]);

        const orcdBasicG = orcdBasicSvg.append("g")
            .attr("transform", `translate(${orcdBasicMargin.left},${orcdBasicMargin.top})`);

        // Define conceptual ORDC data points (example shape)
        const orcdBasicData = [
            {reserve: 0, price: 2000},
            {reserve: 500, price: 1500},
            {reserve: 1000, price: 500},
            {reserve: 1500, price: 100},
            {reserve: 2000, price: 20},
            {reserve: 3000, price: 0}
        ];

        orcdBasicX.domain([0, 3000]);
        orcdBasicY.domain([0, 2100]); // Max price + buffer

        orcdBasicG.append("g")
            .attr("class", "axis axis--x")
            .attr("transform", `translate(0,${orcdBasicHeight})`)
            .call(d3.axisBottom(orcdBasicX).ticks(6))
            .append("text")
              .attr("fill", "#000")
              .attr("x", orcdBasicWidth / 2)
              .attr("y", 25)
              .attr("dy", "0.71em")
              .attr("text-anchor", "middle")
              .style("font-size", "10px")
              .text("Available Reserves (MW)");


        orcdBasicG.append("g")
            .attr("class", "axis axis--y")
            .call(d3.axisLeft(orcdBasicY).ticks(5).tickFormat(d => `$${d}`))
            .append("text")
              .attr("fill", "#000")
              .attr("transform", "rotate(-90)")
              .attr("y", -40)
              .attr("x", -orcdBasicHeight / 2)
            //   .attr("dy", "0.71em")
              .attr("text-anchor", "middle")
              .style("font-size", "10px")
              .text("Scarcity Price ($/MWh)");

        const orcdBasicLine = d3.line()
            .x(d => orcdBasicX(d.reserve))
            .y(d => orcdBasicY(d.price))
            .curve(d3.curveStepAfter); // Use step curve for this example

        orcdBasicG.append("path")
            .datum(orcdBasicData)
            .attr("class", "line")
            .attr("d", orcdBasicLine);

        const reserveMarker = orcdBasicG.append("circle")
            .attr("class", "reserve-marker")
            .attr("r", 5);

        const priceLine = orcdBasicG.append("line")
             .attr("stroke", "red")
             .attr("stroke-dasharray", "4")
             .attr("stroke-width", 1);

        function updateBasicORDC() {
            const currentReserve = +reserveSlider.value;
            reserveDisplay.textContent = currentReserve;

            // Find the price on the step curve
            let currentPrice = 0;
            for (let i = 0; i < orcdBasicData.length - 1; i++) {
                if (currentReserve >= orcdBasicData[i].reserve && currentReserve < orcdBasicData[i+1].reserve) {
                     currentPrice = orcdBasicData[i].price;
                     break;
                }
                // Handle edge case for max reserve
                if (currentReserve >= orcdBasicData[orcdBasicData.length-1].reserve) {
                    currentPrice = orcdBasicData[orcdBasicData.length-1].price;
                }
                 // Handle edge case for min reserve
                 if (currentReserve < orcdBasicData[0].reserve) {
                     currentPrice = orcdBasicData[0].price; // Should technically be higher based on curve def
                 }
            }
             // Handle the last segment explicitely if needed (or adjust loop)
             if (currentReserve >= orcdBasicData[orcdBasicData.length - 1].reserve) {
                 currentPrice = orcdBasicData[orcdBasicData.length - 1].price;
             } else if (currentReserve < orcdBasicData[0].reserve) {
                 // Assume price stays high below the first defined point for this viz
                 currentPrice = orcdBasicData[0].price;
             } else {
                 // Find the correct step
                 for (let i = 0; i < orcdBasicData.length -1; i++) {
                      if (currentReserve >= orcdBasicData[i].reserve && currentReserve < orcdBasicData[i+1].reserve) {
                          currentPrice = orcdBasicData[i].price;
                          break;
                      }
                 }
             }


            priceDisplay.textContent = currentPrice.toFixed(0);

            reserveMarker
                .attr("cx", orcdBasicX(currentReserve))
                .attr("cy", orcdBasicY(currentPrice));

            priceLine
                 .attr("x1", orcdBasicX(0))
                 .attr("y1", orcdBasicY(currentPrice))
                 .attr("x2", orcdBasicX(currentReserve))
                 .attr("y2", orcdBasicY(currentPrice));
        }

        reserveSlider.addEventListener('input', updateBasicORDC);
        updateBasicORDC(); // Initial call


        // --- Visualization 2: ERCOT Adder ---
        const ercotReserveSlider = document.getElementById('ercot-reserve-slider');
        const ercotReserveDisplay = document.getElementById('ercot-reserve-display');
        const ercotVollSlider = document.getElementById('ercot-voll-slider');
        const ercotVollDisplay = document.getElementById('ercot-voll-display');
        const ercotRreqSlider = document.getElementById('ercot-rreq-slider');
        const ercotRreqDisplay = document.getElementById('ercot-rreq-display');
        const ercotLmpSlider = document.getElementById('ercot-lmp-slider');
        const ercotLmpDisplay = document.getElementById('ercot-lmp-display');

        const ercotAdderValue = document.getElementById('ercot-adder-value');
        const ercotFinalPrice = document.getElementById('ercot-final-price');

        const ercotSvg = d3.select("#ercot-adder-chart").append("svg")
            .attr("width", "100%")
            .attr("height", 250);
        const ercotMargin = {top: 20, right: 30, bottom: 30, left: 50};
        const ercotWidth = ercotSvg.node().getBoundingClientRect().width - ercotMargin.left - ercotMargin.right;
        const ercotHeight = 250 - ercotMargin.top - ercotMargin.bottom;

        const ercotX = d3.scaleLinear().range([0, ercotWidth]);
        const ercotY = d3.scaleLinear().range([ercotHeight, 0]);

        const ercotG = ercotSvg.append("g")
            .attr("transform", `translate(${ercotMargin.left},${ercotMargin.top})`);

        const ercotXAxis = ercotG.append("g")
            .attr("class", "axis axis--x")
            .attr("transform", `translate(0,${ercotHeight})`);

         ercotXAxis.append("text")
              .attr("fill", "#000")
              .attr("x", ercotWidth / 2)
              .attr("y", 25)
              .attr("dy", "0.71em")
              .attr("text-anchor", "middle")
              .style("font-size", "10px")
              .text("Available Reserves (MW)");

        const ercotYAxis = ercotG.append("g")
            .attr("class", "axis axis--y");

         ercotYAxis.append("text")
              .attr("fill", "#000")
              .attr("transform", "rotate(-90)")
              .attr("y", -40)
              .attr("x", -ercotHeight / 2)
              .attr("text-anchor", "middle")
              .style("font-size", "10px")
              .text("Price Adder ($/MWh)");

        const ercotLine = d3.line()
            .x(d => ercotX(d.reserve))
            .y(d => ercotY(d.adder));

        const ercotPath = ercotG.append("path")
            .attr("fill", "none")
            .attr("stroke", "darkorange")
            .attr("stroke-width", 2);

        const ercotMarker = ercotG.append("circle")
            .attr("r", 5)
            .attr("fill", "red")
            .attr("stroke", "darkred");

         // Simplified LOLP function - captures the essence of increasing probability as reserves decrease
         // This is NOT the actual ERCOT formula but gives a similar shape for illustration.
         // It simulates the 1 - CDF(R_avail - R_req | shifted_mean, stddev) idea qualitatively.
         function simplifiedLOLP(available_reserves, r_req, scale_factor = 2000) {
             const reserve_margin = available_reserves - r_req;
             if (reserve_margin <= 0) return 1.0;
             // Exponential decay as margin increases
             return Math.min(1.0, Math.exp(-reserve_margin / scale_factor));
         }


        function updateErcotAdder() {
            const voll = +ercotVollSlider.value;
            const rReq = +ercotRreqSlider.value;
            const baseLmp = +ercotLmpSlider.value;
            const currentReserve = +ercotReserveSlider.value;

            ercotReserveDisplay.textContent = currentReserve.toFixed(0);
            ercotVollDisplay.textContent = voll.toFixed(0);
            ercotRreqDisplay.textContent = rReq.toFixed(0);
            ercotLmpDisplay.textContent = baseLmp.toFixed(0);

            const maxPossibleAdder = Math.max(0, voll - baseLmp);

            // Generate data for the curve
            const ercotCurveData = d3.range(2000, 6001, 50).map(res => {
                let adder = 0;
                if (res <= rReq) {
                    adder = maxPossibleAdder;
                } else {
                    const lolp = simplifiedLOLP(res, rReq);
                    adder = Math.max(0, lolp * maxPossibleAdder);
                }
                // Ensure adder doesn't exceed VOLL-LMP
                 adder = Math.min(adder, maxPossibleAdder);
                return { reserve: res, adder: adder };
            });

            // Update domains
            ercotX.domain(d3.extent(ercotCurveData, d => d.reserve));
            // ercotY.domain([0, d3.max(ercotCurveData, d => d.adder) * 1.1 || maxPossibleAdder * 1.1]);
             ercotY.domain([0, Math.max(maxPossibleAdder * 1.1, 100)]); // Ensure y-axis isn't too small

            // Update axes
            ercotXAxis.call(d3.axisBottom(ercotX).ticks(5));
            ercotYAxis.call(d3.axisLeft(ercotY).ticks(5).tickFormat(d => `$${d.toFixed(0)}`));

            // Update path
            ercotPath.datum(ercotCurveData)
                .attr("d", ercotLine);

            // Calculate current adder
            let currentAdder = 0;
            if (currentReserve <= rReq) {
                currentAdder = maxPossibleAdder;
            } else {
                const currentLOLP = simplifiedLOLP(currentReserve, rReq);
                currentAdder = Math.max(0, currentLOLP * maxPossibleAdder);
            }
             currentAdder = Math.min(currentAdder, maxPossibleAdder); // Ensure cap

            ercotAdderValue.textContent = currentAdder.toFixed(0);
            ercotFinalPrice.textContent = (baseLmp + currentAdder).toFixed(0);

            // Update marker
            ercotMarker
                .attr("cx", ercotX(currentReserve))
                .attr("cy", ercotY(currentAdder));
        }

        ercotReserveSlider.addEventListener('input', updateErcotAdder);
        ercotVollSlider.addEventListener('input', updateErcotAdder);
        ercotRreqSlider.addEventListener('input', updateErcotAdder);
        ercotLmpSlider.addEventListener('input', updateErcotAdder);
        updateErcotAdder(); // Initial call


         // --- Visualization 3: Stepwise ORDC ---
         const stepReserveSlider = document.getElementById('step-reserve-slider');
         const stepReserveDisplay = document.getElementById('step-reserve-display');
         const stepPenaltyDisplay = document.getElementById('step-penalty-display');
         const stepSvg = d3.select("#step-ordc-chart").append("svg")
             .attr("width", "100%")
             .attr("height", 200);
         const stepMargin = {top: 20, right: 30, bottom: 30, left: 50};
         const stepWidth = stepSvg.node().getBoundingClientRect().width - stepMargin.left - stepMargin.right;
         const stepHeight = 200 - stepMargin.top - stepMargin.bottom;

         const stepX = d3.scaleLinear().range([0, stepWidth]);
         const stepY = d3.scaleLinear().range([stepHeight, 0]);

         const stepG = stepSvg.append("g")
             .attr("transform", `translate(${stepMargin.left},${stepMargin.top})`);

         // Define generic step ORDC data (Example: 3 steps)
         // Format: { reserve_threshold, penalty } - Penalty applies *below* threshold
         const stepData = [
             { threshold: 4000, penalty: 0 },    // Above 3000 MW, penalty is 0
             { threshold: 3000, penalty: 300 },  // Between 1500 and 3000, penalty is 300
             { threshold: 1500, penalty: 850 },  // Between 0 and 1500, penalty is 850
             { threshold: 0, penalty: 850 }      // Below 0 (for drawing purposes)
         ];

          // Convert to plottable segments for step function
          const stepSegments = [];
            for (let i = stepData.length - 1; i > 0; i--) {
                stepSegments.push({ reserve: stepData[i].threshold, penalty: stepData[i-1].penalty });
                stepSegments.push({ reserve: stepData[i-1].threshold, penalty: stepData[i-1].penalty });
            }
            // Add a point at the max extent with the lowest penalty
            stepSegments.push({reserve: 4000, penalty: stepData[0].penalty})


         stepX.domain([0, 4000]);
         stepY.domain([0, d3.max(stepData, d => d.penalty) * 1.1 || 1000]);

         stepG.append("g")
             .attr("class", "axis axis--x")
             .attr("transform", `translate(0,${stepHeight})`)
             .call(d3.axisBottom(stepX).ticks(5))
              .append("text")
              .attr("fill", "#000")
              .attr("x", stepWidth / 2)
              .attr("y", 25)
              .attr("dy", "0.71em")
              .attr("text-anchor", "middle")
              .style("font-size", "10px")
              .text("Available Reserves (MW)");


         stepG.append("g")
             .attr("class", "axis axis--y")
             .call(d3.axisLeft(stepY).ticks(4).tickFormat(d => `$${d}`))
             .append("text")
              .attr("fill", "#000")
              .attr("transform", "rotate(-90)")
              .attr("y", -40)
              .attr("x", -stepHeight / 2)
              .attr("text-anchor", "middle")
              .style("font-size", "10px")
              .text("Penalty ($/MWh)");


         const stepLine = d3.line()
             .x(d => stepX(d.reserve))
             .y(d => stepY(d.penalty))
             .curve(d3.curveLinear); // Use linear for segments, looks like steps

         stepG.append("path")
             .datum(stepSegments.sort((a, b) => a.reserve - b.reserve)) // Ensure sorted for line
             .attr("fill", "none")
             .attr("stroke", "steelblue")
             .attr("stroke-width", 2)
             .attr("d", stepLine);

         const stepMarker = stepG.append("circle")
             .attr("r", 5)
             .attr("fill", "red")
             .attr("stroke", "darkred");

         function updateStepORDC() {
             const currentReserve = +stepReserveSlider.value;
             stepReserveDisplay.textContent = currentReserve.toFixed(0);

             let currentPenalty = 0;
             // Find the penalty based on the thresholds
             for (let i = 1; i < stepData.length; i++) {
                 if (currentReserve < stepData[i-1].threshold && currentReserve >= stepData[i].threshold ) {
                     currentPenalty = stepData[i].penalty;
                     break;
                 }
             }
             // Handle case above highest threshold
             if (currentReserve >= stepData[0].threshold) {
                 currentPenalty = stepData[0].penalty;
             }
              // Handle case below lowest threshold
             if (currentReserve < stepData[stepData.length-1].threshold) {
                 currentPenalty = stepData[stepData.length-1].penalty;
             }


             stepPenaltyDisplay.textContent = currentPenalty.toFixed(0);

             stepMarker
                 .attr("cx", stepX(currentReserve))
                 .attr("cy", stepY(currentPenalty));
         }

         stepReserveSlider.addEventListener('input', updateStepORDC);
         updateStepORDC(); // Initial call


        // --- Visualization 4: Comparative Chart ---
        const isoSelect = document.getElementById('iso-select');
        const compareReserveSlider = document.getElementById('compare-reserve-slider');
        const compareReserveDisplay = document.getElementById('compare-reserve-display');
        const comparePremiumDisplay = document.getElementById('compare-premium-display');

        const compareSvg = d3.select("#comparative-chart").append("svg")
            .attr("width", "100%")
            .attr("height", 400); // Taller chart
        const compareMargin = {top: 20, right: 30, bottom: 40, left: 60}; // Increased bottom/left margin
        const compareWidth = compareSvg.node().getBoundingClientRect().width - compareMargin.left - compareMargin.right;
        const compareHeight = 400 - compareMargin.top - compareMargin.bottom;

        const compareX = d3.scaleLinear().domain([0, 10]).range([0, compareWidth]); // Reserves 0-10 GW
        const compareY = d3.scaleLinear().domain([0, 5500]).range([compareHeight, 0]); // Max price up to VOLL+

        const compareG = compareSvg.append("g")
            .attr("transform", `translate(${compareMargin.left},${compareMargin.top})`);

        // Add X axis
        compareG.append("g")
            .attr("transform", `translate(0,${compareHeight})`)
            .call(d3.axisBottom(compareX).ticks(10))
             .append("text")
              .attr("fill", "#000")
              .attr("x", compareWidth / 2)
              .attr("y", 35) // Adjusted position
              .attr("text-anchor", "middle")
              .style("font-size", "12px")
              .text("Available Reserves (GW)");

        // Add Y axis
        compareG.append("g")
            .call(d3.axisLeft(compareY).ticks(6).tickFormat(d => `$${d}`))
            .append("text")
              .attr("fill", "#000")
              .attr("transform", "rotate(-90)")
              .attr("y", -45) // Adjusted position
              .attr("x", -compareHeight / 2)
              .attr("text-anchor", "middle")
              .style("font-size", "12px")
              .text("Scarcity Premium ($/MWh)");

        // Add gridlines
         compareG.append("g")
            .attr("class", "grid")
            .attr("transform", `translate(0,${compareHeight})`)
            .call(d3.axisBottom(compareX)
                .ticks(10)
                .tickSize(-compareHeight)
                .tickFormat("")
            );

        compareG.append("g")
            .attr("class", "grid")
            .call(d3.axisLeft(compareY)
                .ticks(6)
                .tickSize(-compareWidth)
                .tickFormat("")
            );

        const compareLine = d3.line()
            .x(d => compareX(d.reserve))
            .y(d => compareY(d.premium))
            .curve(d3.curveLinear); // Use linear, steps handled in data

        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip");

        // --- Data Generation for Comparative Chart ---
        // Simplified representation based on paper's descriptions and Fig 11 logic
        // Base assumptions: 3 GW min contingency reserve. Base LMP $50. Offer caps $1k/$2k.
        function getIsoData() {
            const reservePoints = d3.range(0, 10.1, 0.1); // GW
            const baseLmp = 50;
            const minContReserve = 3; // GW - Below this, major penalties apply

            // --- ERCOT Data ---
            const ercotVoll = 5000;
            const ercotRreq = 3; // GW
            const ercotMaxAdder = Math.max(0, ercotVoll - baseLmp);
            const ercotData = reservePoints.map(r => {
                let adder = 0;
                if (r <= ercotRreq) {
                    adder = ercotMaxAdder;
                } else {
                     // Use a steeper decay for the comparative example to match Fig 11 shape better
                    const lolp = simplifiedLOLP(r, ercotRreq, 750); // Smaller scale factor
                    adder = Math.max(0, lolp * ercotMaxAdder);
                }
                 adder = Math.min(adder, ercotMaxAdder);
                return { reserve: r, premium: adder };
            });

            // --- PJM Data (Steps, No Flex) ---
            // Simplified 2-step: $850 below 3GW, $300 below 3+0.19=3.19GW (using 190MW from paper)
            const pjmCap = 2000; // Energy offer cap
            const pjmStep1Penalty = 850;
            const pjmStep2Penalty = 300;
            const pjmStep1Threshold = minContReserve; // 3 GW
            const pjmStep2Threshold = minContReserve + 0.19; // 3.19 GW
            const pjmData = reservePoints.map(r => {
                let premium = 0;
                if (r < pjmStep1Threshold) premium = pjmStep1Penalty;
                else if (r < pjmStep2Threshold) premium = pjmStep2Penalty;
                // Premium is added to LMP, but capped by offer cap + penalty
                // Simplification: Show the penalty itself as the premium, assuming LMP is low
                return { reserve: r, premium: Math.min(premium, pjmCap) }; // Cap at offer cap
            });

            // --- CAISO Data (Steps, Flex) ---
            // Base $1000 cap. Nested penalties + Flexiramp effect.
            // Simplified: $700 (non-spin) + $100 (spin) + $200 (reg) = $1000 max contingency penalty below 3GW.
            // Add flexiramp effect: Assume linear decay from $247 at ~4GW down to 0 at ~7GW (long tail).
            const caisoCap = 1000;
             const caisoContPenalty = 1000; // Max nested penalty for Reg+Spin+NonSpin below 3GW
             const caisoFlexStartReserve = 7; // GW where flex penalty hits 0
             const caisoFlexPeakReserve = 4; // GW where flex penalty is max
             const caisoFlexMaxPenalty = 247;
            const caisoData = reservePoints.map(r => {
                let premium = 0;
                if (r < minContReserve) {
                    premium = caisoContPenalty;
                }
                 // Add flexiramp effect (simplified linear tail)
                 if (r >= minContReserve && r < caisoFlexStartReserve) {
                     const flexFraction = Math.max(0, (caisoFlexStartReserve - r) / (caisoFlexStartReserve - caisoFlexPeakReserve));
                     premium = Math.max(premium, flexFraction * caisoFlexMaxPenalty);
                 }
                 premium = Math.min(premium, caisoCap); // Apply cap
                return { reserve: r, premium: premium };
            });

            // --- NYISO Data (Steps, No Flex) ---
            // Complex nesting/zonal. Simplified: High penalties below 3GW, maybe $775(reg)+$750(10min)=~$1500 range? Use $1500 for simplicity below 3GW. Rapid drop-off.
             const nyisoCap = 2000;
             const nyisoPenalty = 1500; // Simplified peak penalty
            const nyisoData = reservePoints.map(r => {
                let premium = 0;
                if (r < minContReserve) premium = nyisoPenalty;
                else if (r < minContReserve + 0.2) premium = 500; // Sharp drop-off
                premium = Math.min(premium, nyisoCap);
                return { reserve: r, premium: premium };
            });


             // --- SPP Data (Steps, Flex) ---
             // $1100 op reserve penalty below ~3.5GW? $600 reg penalty. Flex adds tail.
             // Simplified: $1100 below 3GW. Flex adds tail like CAISO but maybe lower max ($250?).
             const sppCap = 2000;
             const sppContPenalty = 1100; // Below 3GW
             const sppFlexStartReserve = 6;
             const sppFlexPeakReserve = 4;
             const sppFlexMaxPenalty = 250; // Assumed max flex from text
             const sppData = reservePoints.map(r => {
                 let premium = 0;
                 if (r < minContReserve) {
                     premium = sppContPenalty;
                 }
                  // Add flexiramp effect
                  if (r >= minContReserve && r < sppFlexStartReserve) {
                      const flexFraction = Math.max(0, (sppFlexStartReserve - r) / (sppFlexStartReserve - sppFlexPeakReserve));
                      premium = Math.max(premium, flexFraction * sppFlexMaxPenalty);
                  }
                  premium = Math.min(premium, sppCap);
                 return { reserve: r, premium: premium };
             });

             // --- ISO-NE Data (Steps, No Flex) ---
             // $1500 (10min) + $50 (spin) = $1550 below 3GW. $1000 (30min) also possible. Use $1500.
             const isoneCap = 2000;
             const isonePenalty = 1500; // Simplified peak penalty
             const isoneData = reservePoints.map(r => {
                 let premium = 0;
                 if (r < minContReserve) premium = isonePenalty;
                 else if (r < minContReserve + 0.5) premium = 250; // Slower drop-off than NYISO?
                 premium = Math.min(premium, isoneCap);
                 return { reserve: r, premium: premium };
             });

             // --- MISO Data (Steps, Flex) ---
             // $3500 VOLL cap. $1100 penalty below ~3.5GW? Low $5 flex penalty.
             // Simplified: $1100 below 3GW. Very low flex tail ($5).
             const misoCap = 3500;
             const misoContPenalty = 1100; // Below 3GW
             const misoFlexPenalty = 5; // Very low
              const misoFlexStartReserve = 8; // Assume flex applies over wide range but low value
             const misoData = reservePoints.map(r => {
                 let premium = 0;
                 if (r < minContReserve) {
                     premium = misoContPenalty;
                 } else if (r < misoFlexStartReserve) {
                      premium = Math.max(premium, misoFlexPenalty); // Add small flex premium
                 }
                 premium = Math.min(premium, misoCap);
                 return { reserve: r, premium: premium };
             });


            return { ERCOT: ercotData, PJM: pjmData, CAISO: caisoData, NYISO: nyisoData, SPP: sppData, 'ISO-NE': isoneData, MISO: misoData };
        }

        const allIsoData = getIsoData();
        const isoColors = d3.scaleOrdinal(d3.schemeCategory10).domain(Object.keys(allIsoData));

        const comparePaths = compareG.selectAll(".line")
            .data(Object.entries(allIsoData))
            .enter().append("path")
            .attr("class", "line compare-line")
            .attr("fill", "none")
            .attr("stroke-width", 2.5)
            .style("opacity", 0.8)
            .attr("stroke", d => isoColors(d[0]))
            .attr("d", d => compareLine(d[1]))
             .on("mouseover", (event, d) => {
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(d[0])
                    .style("left", (event.pageX + 5) + "px")
                    .style("top", (event.pageY - 28) + "px");
                 // Highlight line
                 d3.selectAll(".compare-line").style("opacity", 0.2);
                 d3.select(event.currentTarget).style("opacity", 1).style("stroke-width", 4);

            })
            .on("mouseout", (event, d) => {
                tooltip.transition().duration(500).style("opacity", 0);
                 // Restore opacity
                 updateCompareChart(); // Redraw based on selection
            });


        const compareMarker = compareG.append("line") // Use a vertical line marker
             .attr("stroke", "#333")
             .attr("stroke-width", 1.5)
             .attr("stroke-dasharray", "6,3");

         function updateCompareChart() {
             const selectedIso = isoSelect.value;
             const currentReserve = +compareReserveSlider.value;
             compareReserveDisplay.textContent = currentReserve.toFixed(1);

             let currentPremium = 0;

             comparePaths.each(function(d) {
                 const isoName = d[0];
                 const isoData = d[1];
                 const path = d3.select(this);

                 if (selectedIso === "ALL" || selectedIso === isoName) {
                     path.style("display", null).style("opacity", 0.8).style("stroke-width", 2.5); // Show
                     if (selectedIso === isoName) {
                         // Find premium for the selected ISO at current reserve
                         // Interpolate between points for smoother value display
                         const bisect = d3.bisector(data => data.reserve).left;
                         const index = bisect(isoData, currentReserve);
                         const p0 = isoData[index - 1] || isoData[0];
                         const p1 = isoData[index] || isoData[isoData.length - 1];
                         // Simple linear interpolation
                         if (p0 && p1 && p1.reserve !== p0.reserve) {
                             currentPremium = p0.premium + (p1.premium - p0.premium) * (currentReserve - p0.reserve) / (p1.reserve - p0.reserve);
                         } else if (p0) {
                             currentPremium = p0.premium;
                         } else {
                             currentPremium = 0;
                         }
                         path.style("opacity", 1).style("stroke-width", 4); // Highlight selected
                     }
                 } else {
                     path.style("display", "none"); // Hide
                 }
             });

             comparePremiumDisplay.textContent = currentPremium.toFixed(0);

             // Update marker position
             compareMarker
                 .attr("x1", compareX(currentReserve))
                 .attr("y1", compareY(0))
                 .attr("x2", compareX(currentReserve))
                 .attr("y2", compareY(compareY.domain()[1])); // Top of chart
                 // .attr("y2", compareY(currentPremium)); // Could marker line go to premium? No, vertical line better.
         }

         isoSelect.addEventListener('change', updateCompareChart);
         compareReserveSlider.addEventListener('input', updateCompareChart);
         updateCompareChart(); // Initial call

    });
    </script>

</body>
</html>