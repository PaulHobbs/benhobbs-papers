<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untangling the Grid: How Market Rules Shape Our Energy Future</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- MathJax -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
        };
      </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa; /* Light background */
        }
        .container {
            max-width: 900px;
            margin-top: 2rem;
            margin-bottom: 2rem;
            background-color: #ffffff; /* White content area */
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.05);
        }
        h1, h2, h3 {
            color: #2c3e50; /* Dark blue-grey heading */
            margin-bottom: 1rem;
        }
        h1 { font-size: 2.5rem; border-bottom: 2px solid #e0e0e0; padding-bottom: 0.5rem; }
        h2 { font-size: 1.75rem; margin-top: 2.5rem; border-bottom: 1px solid #eee; padding-bottom: 0.3rem;}
        h3 { font-size: 1.4rem; margin-top: 2rem; color: #34495e; }
        p, li {
            font-size: 1.1rem;
            margin-bottom: 1rem;
        }
        a {
            color: #3498db; /* Blue links */
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        code {
            background-color: #ecf0f1; /* Light grey code background */
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }
        .math-block {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #eee;
            overflow-x: auto;
            margin-bottom: 1rem;
        }
        .interactive-viz {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 1.5rem;
            margin-top: 1.5rem;
            margin-bottom: 2rem;
            background-color: #fdfdfd;
        }
        .slider-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        .slider-value {
            font-weight: bold;
            color: #2980b9;
        }
        .caption {
            font-size: 0.9rem;
            color: #777;
            margin-top: 0.5rem;
            text-align: center;
        }
        .d3-chart svg {
            display: block;
            margin: auto;
        }
        .bar { fill: steelblue; }
        .bar:hover { fill: brown; }
        .axis path,
        .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }
        .axis text {
            font-size: 11px;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 8px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
        }
        .btn-group .btn { margin-right: 5px; }
        .explanation-box {
            background-color: #eaf2f8;
            border-left: 5px solid #3498db;
            padding: 15px;
            margin: 1.5rem 0;
            border-radius: 4px;
        }
        .footer {
            margin-top: 3rem;
            text-align: center;
            font-size: 0.9rem;
            color: #888;
            border-top: 1px solid #eee;
            padding-top: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">

        <h1>Untangling the Grid: How Market Rules Shape Our Energy Future</h1>
        <p class="lead">Inspired by the paper: "The impact of market design and clean energy incentives on strategic generation investments and resource adequacy in low-carbon electricity markets" by Kwon et al. (2023).</p>

        <p>Keeping the lights on reliably and affordably while transitioning to cleaner energy sources is one of the biggest challenges of our time. The electric grid is a complex machine, and the rules governing how electricity is bought and sold – the <a href="https://en.wikipedia.org/wiki/Electricity_market" target="_blank">electricity market design</a> – play a crucial role. But how do these rules actually influence the decisions of power plant owners? And do different rules lead to a more reliable, cleaner, or cheaper grid?</p>

        <p>This post explores these questions, drawing insights from a recent research paper by Jonghwan Kwon and colleagues. We'll delve into how companies decide whether to build new power plants (like wind farms or natural gas turbines) or retire old ones, and how different market structures nudge these decisions in potentially unexpected ways.</p>

        <h2>The Big Picture: Planning for Power</h2>

        <p>Imagine you're responsible for ensuring there's enough electricity for a whole region, not just for today, but for years to come. This involves balancing two key aspects:</p>
        <ol>
            <li><strong>Short-Term Operations:</strong> Matching electricity supply with demand *right now*, every minute of every day.</li>
            <li><strong>Long-Term Planning:</strong> Ensuring enough power plants are built (and maintained) to meet future demand reliably, even during peak times or when some plants are unexpectedly offline.</li>
        </ol>

        <p>A key metric for long-term reliability is the <a href="https://en.wikipedia.org/wiki/Reserve_margin" target="_blank">Planning Reserve Margin (PRM)</a>. It's the extra generating capacity available beyond the expected peak demand, usually expressed as a percentage. A higher PRM generally means a more reliable system, but building extra capacity costs money.</p>

        <div class="explanation-box">
            <strong>Planning Reserve Margin (PRM):</strong>
            $$ PRM = \frac{\text{Total Available Capacity} - \text{Peak Demand}}{\text{Peak Demand}} \times 100\% $$
            Think of it as a safety buffer. If peak demand is 100 Megawatts (MW) and you have 115 MW of available power plants, your PRM is 15%.
        </div>

        <h2>Two Worlds: The Ideal Planner vs. Market Reality</h2>

        <p>How do we decide which power plants to build? There are two main perspectives studied in the paper:</p>

        <ol>
            <li><strong>The Central Planner (Least-Cost Generation Expansion Planning - LC-GEP):</strong> Imagine a single, all-knowing entity whose only goal is to meet electricity demand reliably at the *lowest possible total cost* to society. This planner optimizes the mix of power plants based on construction costs, fuel costs, operating costs, and reliability targets (like a specific PRM). This is often how utilities in regulated regions plan, or how researchers establish a theoretical "optimal" benchmark.</li>
            <li><strong>The Competitive Market (Strategic Capacity Investment Model - SCIM):</strong> In many regions (like those run by <a href="https://en.wikipedia.org/wiki/Regional_transmission_organization_(North_America)" target="_blank">ISOs/RTOs</a> in the US), power plants are owned by different companies (<a href="https://en.wikipedia.org/wiki/Generating_company" target="_blank">GenCos</a>) competing in wholesale markets. These GenCos don't aim for the lowest *system* cost; they aim to maximize *their own profits*. They make strategic decisions about building or retiring plants based on expected revenues from selling electricity and other grid services, anticipating how their actions and their competitors' actions will affect market prices. This is modeled using <a href="https://en.wikipedia.org/wiki/Game_theory" target="_blank">game theory</a>, specifically as an <a href="https://en.wikipedia.org/wiki/Mathematical_program_with_equilibrium_constraints" target="_blank">Equilibrium Problem with Equilibrium Constraints (EPEC)</a>.</li>
        </ol>

        <p>The paper highlights that these two approaches can lead to significantly different outcomes for the grid. Let's explore why.</p>

        <h2>Playing the Market Game: How GenCos Decide</h2>

        <p>In the competitive market model (SCIM), GenCos look at potential revenues from different markets:</p>
        <ul>
            <li><strong>Energy Market:</strong> Selling actual electricity ($/MWh) based on hourly supply and demand.</li>
            <li><strong>Capacity Market:</strong> Getting paid for being *available* to generate power in the future, ensuring long-term reliability ($/MW-year).</li>
            <li><strong>Ancillary Services Market:</strong> Providing services like frequency regulation or reserves ($/MW).</li>
            <li><strong>Clean Energy Market (Potential):</strong> Selling "clean attributes" if they use non-emitting sources like wind, solar, or nuclear ($/MWh or $/REC).</li>
        </ul>

        <p>A GenCo will invest in a new power plant only if its expected lifetime revenues from these markets exceed its construction and operating costs. Their decisions are *strategic* – they consider how their investment might affect market prices and how competitors might react.</p>

        <h3>Interactive 1: The Energy Market Dispatch</h3>
        <p>The energy market matches supply offers from generators with demand, typically hour by hour. Cheaper generators are dispatched first. Let's simulate a highly simplified version. Imagine three types of generators with different operating costs. Adjust the demand level and see which generators run and what the market clearing price (the cost of the *last* generator needed) is.</p>

        <div class="interactive-viz">
            <h4>Simplified Energy Dispatch</h4>
            <label for="demandSlider" class="form-label slider-label">Electricity Demand: <span id="demandValue" class="slider-value">500</span> MW</label>
            <input type="range" class="form-range" id="demandSlider" min="0" max="1000" value="500" step="10">

            <div id="dispatchViz" style="margin-top: 1rem; height: 200px; position: relative;"></div>
            <p class="caption" id="dispatchCaption">Generators dispatched to meet demand. The price is set by the most expensive unit running.</p>
        </div>

        <p>Generators earn revenue in this market based on the clearing price for the energy they produce. Plants with low operating costs (like wind or solar, once built) often run whenever available, while more expensive plants (like natural gas peakers) only run when demand is high, potentially setting high prices during those times.</p>

        <h3>Interactive 2: The Capacity Market</h3>
        <p>Energy markets alone might not guarantee enough investment for long-term reliability, especially for plants that run infrequently but are needed during peak times (the "missing money" problem). Capacity markets aim to fix this. A target amount of capacity is desired (based on peak demand plus the PRM), often represented by a demand curve. Generators offer their available capacity, and the market clears at a price where supply meets the demand curve.</p>

        <div class="interactive-viz">
            <h4>Simplified Capacity Market Clearing</h4>
             <label for="supplySliderCM" class="form-label slider-label">Total Available Capacity: <span id="supplyValueCM" class="slider-value">1100</span> MW</label>
            <input type="range" class="form-range" id="supplySliderCM" min="800" max="1300" value="1100" step="10">

            <div id="capacityMarketViz" style="margin-top: 1rem;"></div>
            <p class="caption" id="capacityMarketCaption">Intersection of supply (vertical line) and demand curve determines capacity price.</p>
            <p>Note: This assumes a downward-sloping demand curve, common in many US markets. The curve reflects a target capacity (e.g., 1150 MW for 15% PRM on 1000 MW peak) with decreasing value placed on excess capacity.</p>
        </div>

        <p>Generators clearing in this market receive payments based on the capacity price, providing a revenue stream even if they don't generate much energy, incentivizing them to stay available.</p>

        <h2>Strategic vs. Central Planning: A Tale of Two Grids</h2>

        <p>The paper uses complex models (SCIM/EPEC for strategic behavior, LC-GEP for central planning) to simulate investment decisions under various market rules. A key finding is that the outcomes often differ significantly.</p>

        <p>Let's visualize a simplified comparison. Imagine choosing between building Natural Gas (NGCT - cheaper to build, higher running cost), Solar PV (higher build cost, zero running cost), and Battery Storage (helps manage solar variability). We compare the mix chosen by a profit-maximizing strategic approach (SCIM) versus an idealized least-system-cost approach (LC-GEP), assuming a capacity market exists.</p>

        <div class="interactive-viz">
            <h4>Investment Outcomes: Strategic (SCIM) vs. Central Planner (LC-GEP)</h4>
            <div class="btn-group" role="group" aria-label="Model Type Toggle">
                <button type="button" class="btn btn-primary active" id="btnSCIM">Strategic (SCIM)</button>
                <button type="button" class="btn btn-outline-primary" id="btnLCGEP">Central Planner (LC-GEP)</button>
            </div>
             <label for="capPriceSlider" class="form-label slider-label" style="margin-top: 1rem;">Capacity Market Price Level (Illustrative): <span id="capPriceValue" class="slider-value">Medium</span></label>
            <input type="range" class="form-range" id="capPriceSlider" min="0" max="2" value="1" step="1"> <!-- 0: Low, 1: Medium, 2: High -->

            <div id="mixComparisonViz" class="d3-chart" style="margin-top: 1rem;"></div>
            <p class="caption">Resulting generation mix and Planning Reserve Margin (PRM) under different planning approaches and capacity market signals.</p>
            <div id="prmDisplay" style="text-align: center; font-weight: bold; margin-top: 0.5rem;">PRM: <span id="prmValue">--</span>%</div>
        </div>

        <p>As observed in the paper (and illustrated above):</p>
        <ul>
            <li><strong>Strategic players (SCIM) often build less capacity overall</strong>, resulting in lower Planning Reserve Margins (PRM) compared to the least-cost plan. Why? They might collectively (though not necessarily collusively) benefit from slightly tighter supply which can lead to higher prices during peak times or in capacity markets. They aren't directly responsible for system-wide reliability targets, only their own profits.</li>
            <li><strong>The technology mix can differ.</strong> The paper found SCIM sometimes resulted in less solar PV and potentially different levels of gas turbines or storage compared to LC-GEP, depending on the specific market rules and parameters. Profit incentives don't always align perfectly with lowest system cost.</li>
            <li><strong>System costs are generally higher under SCIM.</strong> The strategic behavior and potentially lower reliability can lead to higher overall costs (including costs from potential load shedding if reliability is too low) compared to the idealized central planner.</li>
        </ul>

        <h2>The Impact of Rules and Incentives</h2>

        <p>The paper explores how specific market rules and policies influence these strategic investment decisions:</p>
        <ul>
            <li><strong>Energy Price Caps & Scarcity Pricing:</strong> Higher price caps or more aggressive scarcity pricing (prices rising sharply when reserves are low) in energy-only markets can incentivize investment, but may still struggle to consistently meet reliability targets compared to markets with capacity mechanisms.</li>
            <li><strong>Capacity Market Demand Curve Shape:</strong> The steepness and target level of the capacity demand curve significantly impacts how much capacity gets built and the revenue for different types of generators.</li>
            <li><strong>Clean Energy Incentives:</strong>
                <ul>
                    <li><strong>Tax Credits (like US PTC/ITC):</strong> Directly reduce the cost of wind and solar, encouraging their deployment under both SCIM and LC-GEP, though the exact mix might still differ.</li>
                    <li><strong>Carbon Pricing:</strong> Makes fossil fuels more expensive, boosting investment in renewables and storage. The paper suggests this can be effective in driving cleaner investments strategically.</li>
                    <li><strong>Clean Energy Markets (CEM):</strong> Creates a separate market for "clean attributes". Its effectiveness depends heavily on the target quantity and the price offered for these attributes. It might promote clean energy but needs careful design to avoid issues like double-compensation (paying for capacity *and* clean attributes separately).</li>
                </ul>
            </li>
        </ul>

        <h3>Interactive 3: The Effect of a Carbon Price</h3>
        <p>Let's revisit the SCIM vs. LC-GEP comparison, but now introduce a carbon price. See how adding a cost to CO2 emissions shifts the investment mix, particularly for the strategic players.</p>

         <div class="interactive-viz">
            <h4>Impact of Carbon Pricing on Investments</h4>
             <div class="btn-group" role="group" aria-label="Model Type Toggle Carbon">
                <button type="button" class="btn btn-primary active" id="btnSCIM_CP">Strategic (SCIM)</button>
                <button type="button" class="btn btn-outline-primary" id="btnLCGEP_CP">Central Planner (LC-GEP)</button>
            </div>
             <label for="carbonPriceSlider" class="form-label slider-label" style="margin-top: 1rem;">Carbon Price ($/ton CO2): $<span id="carbonPriceValue" class="slider-value">0</span></label>
            <input type="range" class="form-range" id="carbonPriceSlider" min="0" max="100" value="0" step="5">

            <div id="carbonImpactViz" class="d3-chart" style="margin-top: 1rem;"></div>
             <p class="caption">How carbon pricing influences the generation mix chosen strategically vs. by a central planner.</p>
             <div id="prmDisplay_CP" style="text-align: center; font-weight: bold; margin-top: 0.5rem;">PRM: <span id="prmValue_CP">--</span>%</div>
        </div>

        <p>As the paper indicates, a carbon price makes carbon-emitting generation (like NGCT) less profitable, encouraging strategic investment shifts towards renewables (PV) and potentially storage, bringing the SCIM outcome closer to a low-carbon LC-GEP outcome in terms of emissions, although differences in total capacity and PRM might remain.</p>


        <h2>Key Takeaways</h2>

        <p>The research by Kwon et al. provides valuable insights for policymakers and anyone interested in the energy transition:</p>
        <ul>
            <li><strong>Market Design Matters Profoundly:</strong> The specific rules of electricity markets significantly influence investment decisions, the resulting generation mix, system reliability (PRM), and overall cost.</li>
            <li><strong>Strategic Behavior is Real:</strong> Ignoring the profit-maximizing goals and strategic interactions of generation companies can lead to overly optimistic predictions about grid reliability and cost. Models like SCIM/EPEC are crucial for understanding potential real-world outcomes.</li>
            <li><strong>No Perfect Market (Yet):</strong> Energy-only markets may struggle with reliability without robust scarcity pricing. Capacity markets help reliability but need careful design of demand curves and parameters. Clean energy incentives are important but their effectiveness varies.</li>
            <li><strong>Alignment is Key:</strong> Designing markets where individual profit motives align better with system-wide goals of reliability, affordability, and decarbonization is essential for a smooth energy transition.</li>
            <li><strong>Both Models are Useful:</strong> Least-cost models (LC-GEP) provide a useful benchmark for the societal optimum, while strategic models (SCIM/EPEC) offer a more realistic view of market-driven outcomes. Using both provides a richer understanding.</li>
        </ul>

        <p>Understanding these dynamics is critical as we navigate the complex path towards a reliable, affordable, and clean electricity grid for the future.</p>

        <div class="footer">
            <p>This post is an interpretation of the core concepts presented in the paper "The impact of market design and clean energy incentives on strategic generation investments and resource adequacy in low-carbon electricity markets" by J. Kwon, T. Levin, Z. Zhou, A. Botterud, M. Mehrtash, B. F. Hobbs, published in Renewable Energy Focus, 2023. <a href="https://doi.org/10.1016/j.ref.2023.100495" target="_blank">View the original paper</a>.</p>
            <p>Interactive visualizations are simplified illustrations inspired by the paper's findings and are not exact numerical replications.</p>
        </div>

    </div> <!-- /container -->

    <!-- Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>

    <!-- Inline Javascript for visualizations -->
    <script>
        // --- Interactive 1: Energy Dispatch ---
        const demandSlider = document.getElementById('demandSlider');
        const demandValue = document.getElementById('demandValue');
        const dispatchViz = d3.select('#dispatchViz');
        const dispatchCaption = document.getElementById('dispatchCaption');

        const generators = [
            { name: 'Wind/Solar', capacity: 300, cost: 5, color: '#2ecc71' }, // Green
            { name: 'Efficient Gas (NGCC)', capacity: 400, cost: 25, color: '#3498db' }, // Blue
            { name: 'Peaker Gas (NGCT)', capacity: 300, cost: 50, color: '#e74c3c' }  // Red
        ];
        const totalCapacity = generators.reduce((sum, gen) => sum + gen.capacity, 0);

        function updateDispatch() {
            const demand = +demandSlider.value;
            demandValue.textContent = demand;

            let dispatchedCapacity = 0;
            let clearingPrice = 0;
            let runningGenerators = [];

            // Sort generators by cost
            const sortedGenerators = [...generators].sort((a, b) => a.cost - b.cost);

            for (const gen of sortedGenerators) {
                if (dispatchedCapacity < demand) {
                    const capacityToDispatch = Math.min(gen.capacity, demand - dispatchedCapacity);
                    if (capacityToDispatch > 0) {
                         runningGenerators.push({ ...gen, dispatched: capacityToDispatch });
                         dispatchedCapacity += capacityToDispatch;
                         clearingPrice = gen.cost; // Price set by the marginal generator
                    }
                } else {
                    // Add non-running generators for visualization completeness
                    runningGenerators.push({ ...gen, dispatched: 0 });
                }
            }
             // Add remaining non-running generators if demand is low
            const runningNames = new Set(runningGenerators.map(g => g.name));
            sortedGenerators.forEach(gen => {
                if (!runningNames.has(gen.name)) {
                    runningGenerators.push({ ...gen, dispatched: 0 });
                }
            });
             runningGenerators.sort((a, b) => a.cost - b.cost); // Keep original sort order for display


            dispatchViz.selectAll('*').remove(); // Clear previous viz

            const barHeight = 40;
            const barMargin = 10;
            const totalVizHeight = runningGenerators.length * (barHeight + barMargin);
            dispatchViz.style('height', totalVizHeight + 'px');

             let yOffset = 0;
            runningGenerators.forEach(gen => {
                const group = dispatchViz.append('g')
                    .attr('transform', `translate(0, ${yOffset})`);

                // Background bar for total capacity
                 group.append('rect')
                    .attr('width', gen.capacity * 0.5) // Scale width for viz
                    .attr('height', barHeight)
                    .attr('fill', '#eee');

                // Foreground bar for dispatched capacity
                 group.append('rect')
                    .attr('width', gen.dispatched * 0.5) // Scale width for viz
                    .attr('height', barHeight)
                    .attr('fill', gen.color);

                 group.append('text')
                    .attr('x', 5)
                    .attr('y', barHeight / 2)
                    .attr('dy', '0.35em')
                    .attr('fill', 'black')
                    .style('font-size', '12px')
                    .text(`${gen.name} ($${gen.cost}/MWh)`);

                 group.append('text')
                     .attr('x', gen.capacity * 0.5 + 5) // Position text after the bar
                     .attr('y', barHeight / 2)
                     .attr('dy', '0.35em')
                     .attr('fill', 'black')
                     .style('font-size', '12px')
                     .text(`Dispatched: ${gen.dispatched} MW`);

                 yOffset += barHeight + barMargin;
            });


            if (dispatchedCapacity < demand) {
                dispatchCaption.textContent = `Demand (${demand} MW) exceeds available capacity (${dispatchedCapacity} MW)! Price capped or reflects shortage value.`;
                 // Show unmet demand visually? Maybe add a red bar?
            } else {
                 dispatchCaption.textContent = `Meeting ${demand} MW demand. Clearing Price: $${clearingPrice}/MWh (set by ${runningGenerators.find(g=>g.cost === clearingPrice)?.name || 'N/A'}).`;
            }
        }

        demandSlider.addEventListener('input', updateDispatch);
        updateDispatch(); // Initial call

        // --- Interactive 2: Capacity Market ---
        const supplySliderCM = document.getElementById('supplySliderCM');
        const supplyValueCM = document.getElementById('supplyValueCM');
        const capacityMarketVizContainer = d3.select('#capacityMarketViz');
        const capacityMarketCaption = document.getElementById('capacityMarketCaption');

        // Simplified Capacity Demand Curve parameters (Illustrative)
        // Assumes Peak Demand = 1000 MW, Target PRM = 15% -> Target Capacity = 1150 MW
        const targetCapacity = 1150;
        const netCONE = 100; // Cost of New Entry (illustrative price, $/MW-day or similar unit)
        const curveWidth = 100; // How wide the sloped part is

        const cmMargin = {top: 20, right: 30, bottom: 40, left: 50};
        const cmWidth = 450 - cmMargin.left - cmMargin.right;
        const cmHeight = 250 - cmMargin.top - cmMargin.bottom;

        const cmSvg = capacityMarketVizContainer.append("svg")
            .attr("width", cmWidth + cmMargin.left + cmMargin.right)
            .attr("height", cmHeight + cmMargin.top + cmMargin.bottom)
            .append("g")
            .attr("transform", `translate(${cmMargin.left},${cmMargin.top})`);

        const cmX = d3.scaleLinear().range([0, cmWidth]);
        const cmY = d3.scaleLinear().range([cmHeight, 0]);

        const cmXAxis = cmSvg.append("g").attr("transform", `translate(0,${cmHeight})`);
        const cmYAxis = cmSvg.append("g");

        cmSvg.append("text") // X axis label
             .attr("transform", `translate(${cmWidth/2}, ${cmHeight + cmMargin.bottom - 5})`)
             .style("text-anchor", "middle")
             .style("font-size", "12px")
             .text("Capacity (MW)");

        cmSvg.append("text") // Y axis label
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - cmMargin.left)
            .attr("x", 0 - (cmHeight / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .text("Price ($/MW-unit)");

        const cmDemandLine = cmSvg.append("path")
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 2);

        const cmSupplyLine = cmSvg.append("line")
            .attr("stroke", "red")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "4");

        const cmIntersectionPoint = cmSvg.append("circle")
            .attr("r", 5)
            .attr("fill", "red");

        function getCapacityPrice(supply) {
            // Simplified demand curve logic
            const flatStart = targetCapacity - curveWidth / 2;
            const flatEnd = targetCapacity + curveWidth / 2;
             if (supply <= flatStart) return netCONE;
             if (supply >= flatEnd) return 0;
             // Linear slope in between
             return netCONE * (1 - (supply - flatStart) / curveWidth);
        }

        function updateCapacityMarket() {
            const supply = +supplySliderCM.value;
            supplyValueCM.textContent = supply;

            const minX = 800; // Fixed domain for consistency
            const maxX = 1300;
            cmX.domain([minX, maxX]);
            cmY.domain([0, netCONE * 1.1]); // Y domain based on NetCONE

            cmXAxis.call(d3.axisBottom(cmX));
            cmYAxis.call(d3.axisLeft(cmY).ticks(5));

            // Generate points for the demand curve
            const curvePoints = d3.range(minX, maxX + 1, 10).map(cap => ({
                 capacity: cap,
                 price: getCapacityPrice(cap)
             }));

            cmDemandLine.datum(curvePoints)
                .attr("d", d3.line()
                    .x(d => cmX(d.capacity))
                    .y(d => cmY(d.price))
                );

            const clearingPrice = getCapacityPrice(supply);

            cmSupplyLine
                .attr("x1", cmX(supply))
                .attr("y1", 0)
                .attr("x2", cmX(supply))
                .attr("y2", cmHeight);

            cmIntersectionPoint
                .attr("cx", cmX(supply))
                .attr("cy", cmY(clearingPrice));

            capacityMarketCaption.textContent = `Available supply: ${supply} MW. Clearing Price: $${clearingPrice.toFixed(2)}/MW-unit.`;
        }

        supplySliderCM.addEventListener('input', updateCapacityMarket);
        updateCapacityMarket(); // Initial call


        // --- Interactive 3: Mix Comparison ---
        const btnSCIM = document.getElementById('btnSCIM');
        const btnLCGEP = document.getElementById('btnLCGEP');
        const capPriceSlider = document.getElementById('capPriceSlider');
        const capPriceValue = document.getElementById('capPriceValue');
        const mixComparisonVizContainer = d3.select('#mixComparisonViz');
        const prmDisplay = document.getElementById('prmDisplay');
        const prmValue = document.getElementById('prmValue');

        let currentModelType = 'SCIM'; // 'SCIM' or 'LCGEP'
        let currentCapPriceLevel = 1; // 0: Low, 1: Medium, 2: High

        // Simplified representative data structure
        // Values are illustrative MW capacity, PRM is %
        const comparisonData = {
            SCIM: {
                LowCapPrice:  { mix: [{tech: 'NGCT', mw: 100}, {tech: 'PV', mw: 300}, {tech: 'Storage', mw: 50}], prm: 8 },
                MediumCapPrice: { mix: [{tech: 'NGCT', mw: 200}, {tech: 'PV', mw: 400}, {tech: 'Storage', mw: 100}], prm: 11 },
                HighCapPrice: { mix: [{tech: 'NGCT', mw: 250}, {tech: 'PV', mw: 450}, {tech: 'Storage', mw: 150}], prm: 12 }
            },
            LCGEP: {
                 LowCapPrice:  { mix: [{tech: 'NGCT', mw: 50}, {tech: 'PV', mw: 500}, {tech: 'Storage', mw: 100}], prm: 13 },
                 MediumCapPrice: { mix: [{tech: 'NGCT', mw: 100}, {tech: 'PV', mw: 550}, {tech: 'Storage', mw: 150}], prm: 15 },
                 HighCapPrice: { mix: [{tech: 'NGCT', mw: 150}, {tech: 'PV', mw: 600}, {tech: 'Storage', mw: 200}], prm: 16 }
            }
        };
        const techColors = { 'NGCT': '#e74c3c', 'PV': '#f1c40f', 'Storage': '#8e44ad' }; // Red, Yellow, Purple

        const mixMargin = {top: 20, right: 20, bottom: 30, left: 40};
        const mixWidth = 400 - mixMargin.left - mixMargin.right;
        const mixHeight = 250 - mixMargin.top - mixMargin.bottom;

        const mixSvg = mixComparisonVizContainer.append("svg")
            .attr("width", mixWidth + mixMargin.left + mixMargin.right)
            .attr("height", mixHeight + mixMargin.top + mixMargin.bottom)
            .append("g")
            .attr("transform", `translate(${mixMargin.left},${mixMargin.top})`);

        const mixX = d3.scaleBand().range([0, mixWidth]).padding(0.1);
        const mixY = d3.scaleLinear().range([mixHeight, 0]);

        const mixXAxis = mixSvg.append("g").attr("transform", `translate(0,${mixHeight})`);
        const mixYAxis = mixSvg.append("g");

        mixSvg.append("text") // Y axis label
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - mixMargin.left)
            .attr("x", 0 - (mixHeight / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .text("Capacity (Illustrative MW)");

        const mixTooltip = d3.select("body").append("div")
            .attr("class", "tooltip");

        function updateMixComparison() {
            const priceLevelKey = currentCapPriceLevel === 0 ? 'LowCapPrice' : (currentCapPriceLevel === 1 ? 'MediumCapPrice' : 'HighCapPrice');
            const data = comparisonData[currentModelType][priceLevelKey];
            const mix = data.mix;

            mixX.domain(mix.map(d => d.tech));
            mixY.domain([0, d3.max(Object.values(comparisonData).flatMap(model => Object.values(model).flatMap(price => price.mix)), d => d.mw) * 1.1 || 100]); // Dynamic Y domain

            mixXAxis.call(d3.axisBottom(mixX));
            mixYAxis.transition().duration(300).call(d3.axisLeft(mixY).ticks(5));

            const bars = mixSvg.selectAll(".bar").data(mix, d => d.tech);

            bars.exit().remove();

            bars.enter().append("rect")
                .attr("class", "bar")
                .attr("x", d => mixX(d.tech))
                .attr("width", mixX.bandwidth())
                .attr("y", mixHeight) // Start from bottom for transition
                .attr("height", 0)
                .attr("fill", d => techColors[d.tech])
                .on("mouseover", (event, d) => {
                    mixTooltip.transition().duration(200).style("opacity", .9);
                    mixTooltip.html(`${d.tech}: ${d.mw} MW`)
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY - 28) + "px");
                 })
                .on("mouseout", () => {
                    mixTooltip.transition().duration(500).style("opacity", 0);
                 })
                .merge(bars) // Update existing bars
                .transition().duration(500)
                .attr("x", d => mixX(d.tech))
                .attr("width", mixX.bandwidth())
                .attr("y", d => mixY(d.mw))
                .attr("height", d => mixHeight - mixY(d.mw))
                .attr("fill", d => techColors[d.tech]);


            prmValue.textContent = data.prm;

            // Update button states
            btnSCIM.classList.toggle('active', currentModelType === 'SCIM');
            btnSCIM.classList.toggle('btn-primary', currentModelType === 'SCIM');
            btnSCIM.classList.toggle('btn-outline-primary', currentModelType !== 'SCIM');
            btnLCGEP.classList.toggle('active', currentModelType === 'LCGEP');
            btnLCGEP.classList.toggle('btn-primary', currentModelType === 'LCGEP');
            btnLCGEP.classList.toggle('btn-outline-primary', currentModelType !== 'LCGEP');

            // Update slider label
             const priceLabels = ['Low', 'Medium', 'High'];
             capPriceValue.textContent = priceLabels[currentCapPriceLevel];

        }

        btnSCIM.addEventListener('click', () => { currentModelType = 'SCIM'; updateMixComparison(); });
        btnLCGEP.addEventListener('click', () => { currentModelType = 'LCGEP'; updateMixComparison(); });
        capPriceSlider.addEventListener('input', (e) => { currentCapPriceLevel = +e.target.value; updateMixComparison(); });

        updateMixComparison(); // Initial call


        // --- Interactive 4: Carbon Price Impact ---
        // Very similar structure to Mix Comparison, reusing tech colors etc.
        const btnSCIM_CP = document.getElementById('btnSCIM_CP');
        const btnLCGEP_CP = document.getElementById('btnLCGEP_CP');
        const carbonPriceSlider = document.getElementById('carbonPriceSlider');
        const carbonPriceValue = document.getElementById('carbonPriceValue');
        const carbonImpactVizContainer = d3.select('#carbonImpactViz');
        const prmDisplay_CP = document.getElementById('prmDisplay_CP');
        const prmValue_CP = document.getElementById('prmValue_CP');

        let currentModelType_CP = 'SCIM';
        let currentCarbonPrice = 0;

        // Simplified data showing impact of carbon price ($/ton)
        // Structure: { Model: { CarbonPrice: { mix: [...], prm: ... } } }
        // We need a function to interpolate/select data based on slider
        function getCarbonImpactData(model, carbonPrice) {
            // Example: Linear interpolation between $0 and $100
            const baseData = {
                SCIM: { mix: [{tech: 'NGCT', mw: 200}, {tech: 'PV', mw: 400}, {tech: 'Storage', mw: 100}], prm: 11 },
                LCGEP: { mix: [{tech: 'NGCT', mw: 100}, {tech: 'PV', mw: 550}, {tech: 'Storage', mw: 150}], prm: 15 }
            };
            const highCarbonData = {
                SCIM: { mix: [{tech: 'NGCT', mw: 50}, {tech: 'PV', mw: 600}, {tech: 'Storage', mw: 200}], prm: 13 }, // Less NGCT, more PV/Storage
                LCGEP: { mix: [{tech: 'NGCT', mw: 0}, {tech: 'PV', mw: 700}, {tech: 'Storage', mw: 250}], prm: 17 } // Even less NGCT
            };

            const factor = Math.min(1, carbonPrice / 100); // Normalize price to 0-1 range for interpolation

            const interpolateMix = (baseMix, highMix) => {
                const techSet = new Set([...baseMix.map(d=>d.tech), ...highMix.map(d=>d.tech)]);
                return Array.from(techSet).map(tech => {
                    const baseVal = baseMix.find(d=>d.tech===tech)?.mw || 0;
                    const highVal = highMix.find(d=>d.tech===tech)?.mw || 0;
                    return { tech: tech, mw: Math.round(baseVal + (highVal - baseVal) * factor) };
                });
            };

            const basePrm = baseData[model].prm;
            const highPrm = highCarbonData[model].prm;
            const interpolatedPrm = Math.round(basePrm + (highPrm - basePrm) * factor);

            return {
                mix: interpolateMix(baseData[model].mix, highCarbonData[model].mix),
                prm: interpolatedPrm
            };
        }


        const cpSvg = carbonImpactVizContainer.append("svg") // cp for Carbon Price
            .attr("width", mixWidth + mixMargin.left + mixMargin.right)
            .attr("height", mixHeight + mixMargin.top + mixMargin.bottom)
            .append("g")
            .attr("transform", `translate(${mixMargin.left},${mixMargin.top})`);

        const cpX = d3.scaleBand().range([0, mixWidth]).padding(0.1);
        const cpY = d3.scaleLinear().range([mixHeight, 0]);

        const cpXAxis = cpSvg.append("g").attr("transform", `translate(0,${mixHeight})`);
        const cpYAxis = cpSvg.append("g");

         cpSvg.append("text") // Y axis label
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - mixMargin.left)
            .attr("x", 0 - (mixHeight / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .text("Capacity (Illustrative MW)");

         const cpTooltip = d3.select("body").append("div")
            .attr("class", "tooltip");


        function updateCarbonImpact() {
            currentCarbonPrice = +carbonPriceSlider.value;
            carbonPriceValue.textContent = currentCarbonPrice;

            const data = getCarbonImpactData(currentModelType_CP, currentCarbonPrice);
            const mix = data.mix;

             // Find max MW across potential outcomes for consistent Y scale
             const maxMW = d3.max([0, 50, 100].flatMap(price =>
                 ['SCIM', 'LCGEP'].flatMap(model =>
                     getCarbonImpactData(model, price).mix.map(d => d.mw)
                 )
             ));

            cpX.domain(mix.map(d => d.tech));
            cpY.domain([0, maxMW * 1.1 || 100]); // Dynamic Y domain based on possible outcomes

            cpXAxis.call(d3.axisBottom(cpX));
            cpYAxis.transition().duration(300).call(d3.axisLeft(cpY).ticks(5));

            const bars = cpSvg.selectAll(".bar").data(mix, d => d.tech);

            bars.exit().remove();

            bars.enter().append("rect")
                .attr("class", "bar")
                .attr("x", d => cpX(d.tech))
                .attr("width", cpX.bandwidth())
                .attr("y", mixHeight)
                .attr("height", 0)
                .attr("fill", d => techColors[d.tech])
                .on("mouseover", (event, d) => {
                    cpTooltip.transition().duration(200).style("opacity", .9);
                    cpTooltip.html(`${d.tech}: ${d.mw} MW`)
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY - 28) + "px");
                 })
                .on("mouseout", () => {
                    cpTooltip.transition().duration(500).style("opacity", 0);
                 })
                .merge(bars)
                .transition().duration(500)
                .attr("x", d => cpX(d.tech))
                .attr("width", cpX.bandwidth())
                .attr("y", d => cpY(d.mw))
                .attr("height", d => mixHeight - cpY(d.mw))
                .attr("fill", d => techColors[d.tech]);

            prmValue_CP.textContent = data.prm;

            // Update button states
            btnSCIM_CP.classList.toggle('active', currentModelType_CP === 'SCIM');
            btnSCIM_CP.classList.toggle('btn-primary', currentModelType_CP === 'SCIM');
            btnSCIM_CP.classList.toggle('btn-outline-primary', currentModelType_CP !== 'SCIM');
            btnLCGEP_CP.classList.toggle('active', currentModelType_CP === 'LCGEP');
            btnLCGEP_CP.classList.toggle('btn-primary', currentModelType_CP === 'LCGEP');
            btnLCGEP_CP.classList.toggle('btn-outline-primary', currentModelType_CP !== 'LCGEP');
        }


         btnSCIM_CP.addEventListener('click', () => { currentModelType_CP = 'SCIM'; updateCarbonImpact(); });
         btnLCGEP_CP.addEventListener('click', () => { currentModelType_CP = 'LCGEP'; updateCarbonImpact(); });
         carbonPriceSlider.addEventListener('input', updateCarbonImpact);

         updateCarbonImpact(); // Initial call


    </script>

</body>
</html>